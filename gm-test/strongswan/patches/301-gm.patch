diff --git a/build.sh b/build.sh
new file mode 100755
index 000000000..8898dabb1
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,15 @@
+
+#source /opt/xilinx_linux_gnu/environment-setup-zynq-arch-linux-gnu
+
+export LD_LIBRARY_PATH=/ipsec/lib
+export PKG_CONFIG_PATH=/ipsec/lib/pkgconfig/
+export PKG_CONFIG_LIBDIR=/ipsec/lib/pkgconfig/
+
+./configure   --prefix=/ipsec --host=arm-linux \
+		LDFLAGS="-L/ipsec/lib" \
+		CFLAGS="-I/ipsec/include" \
+		--enable-kernel-libipsec  \
+		--disable-gmp --disable-openssl  \
+		--enable-gmalg --with-gmalg_interior=yes
+make
+make install
diff --git a/conf/Makefile.am b/conf/Makefile.am
index d7917664b..f932a6ccf 100644
--- a/conf/Makefile.am
+++ b/conf/Makefile.am
@@ -78,6 +78,7 @@ plugins = \
 	plugins/lookip.opt \
 	plugins/ntru.opt \
 	plugins/openssl.opt \
+	plugins/gmalg.opt \
 	plugins/osx-attr.opt \
 	plugins/p-cscf.opt \
 	plugins/pkcs11.opt \
diff --git a/conf/plugins/gmalg.opt b/conf/plugins/gmalg.opt
new file mode 100644
index 000000000..6fdd0dd0b
--- /dev/null
+++ b/conf/plugins/gmalg.opt
@@ -0,0 +1,5 @@
+charon.plugins.gmalg.engine_id = pkcs11
+	ENGINE ID to use in the GmAlg plugin.
+
+charon.plugins.gmalg.fips_mode = 0
+	Set Gmalg FIPS mode: disabled(0), enabled(1), Suite B enabled(2).
diff --git a/configure.ac b/configure.ac
index ac9ca9be5..de10f7dfb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -68,6 +68,7 @@ ARG_WITH_SET([capabilities],         [no], [set capability dropping library. Cur
 ARG_WITH_SET([mpz_powm_sec],         [yes], [use the more side-channel resistant mpz_powm_sec in libgmp, if available])
 ARG_WITH_SET([dev-headers],          [no], [install strongSwan development headers to directory.])
 ARG_WITH_SET([printf-hooks],         [auto], [force the use of a specific printf hook implementation (auto, builtin, glibc, vstr).])
+ARG_WITH_SET([gmalg_interior],       [yes], [ gmalg build target (yes, no).])
 ARG_WITH_SET([rubygemdir],           ["gem environment gemdir"], [path to install ruby gems to])
 ARG_WITH_SET([pythoneggdir],         ["main site-packages directory"], [path to install python eggs to to])
 
@@ -144,6 +145,7 @@ ARG_ENABL_SET([newhope],        [enable New Hope crypto plugin.])
 ARG_DISBL_SET([nonce],          [disable nonce generation plugin.])
 ARG_ENABL_SET([ntru],           [enables the NTRU crypto plugin.])
 ARG_ENABL_SET([openssl],        [enables the OpenSSL crypto plugin.])
+ARG_ENABL_SET([gmalg],          [enables the GmAlg crypto plugin.])
 ARG_ENABL_SET([padlock],        [enables VIA Padlock crypto plugin.])
 ARG_DISBL_SET([random],         [disable RNG implementation on top of /dev/(u)random.])
 ARG_DISBL_SET([rc2],            [disable RC2 software implementation plugin.])
@@ -357,7 +359,7 @@ AC_SUBST(PLUGIN_CFLAGS)
 AC_PROG_CC
 AM_PROG_CC_C_O
 
-AC_LIB_PREFIX
+#AC_LIB_PREFIX
 AC_C_BIGENDIAN
 
 # =========================
@@ -1148,6 +1150,23 @@ if test x$openssl = xtrue; then
 	AC_CHECK_HEADER([openssl/evp.h],,[AC_MSG_ERROR([OpenSSL header openssl/evp.h not found!])])
 fi
 
+if test x$gmalg = xtrue; then
+	if test "gmalg_interior" = yes; then
+		if test "x$windows" = xtrue; then
+			gmalg_lib=gmalg
+			AC_CHECK_LIB([$gmalg_lib],[gmalg_init],[LIBS="$LIBS"],
+				[AC_MSG_RESULT([no]);gmalg_lib=""],[$DLLIB])
+		fi
+		if test -z "$gmalg_lib"; then
+			gmalg_lib=gmalg
+			AC_CHECK_LIB([$gmalg_lib],[GMALG_LibTest],[LIBS="$LIBS"],
+				[AC_MSG_ERROR([GmAlg lib$gmalg_lib not found])],[$DLLIB])
+		fi
+		AC_SUBST(GMALG_LIB, [-l$gmalg_lib])
+		AC_CHECK_HEADER([gmalg.h],,[AC_MSG_ERROR([GmAlg header gmalg.h not found!])])
+	fi
+fi
+
 if test x$gcrypt = xtrue; then
 	AC_CHECK_LIB([gcrypt],[gcry_control],[LIBS="$LIBS"],[AC_MSG_ERROR([gcrypt library not found])],[-lgpg-error])
 	AC_CHECK_HEADER([gcrypt.h],,[AC_MSG_ERROR([gcrypt header gcrypt.h not found!])])
@@ -1411,6 +1430,7 @@ ADD_PLUGIN([ipseckey],             [c charon])
 ADD_PLUGIN([pem],                  [s charon scepclient pki scripts manager medsrv attest nm cmd aikgen fuzz])
 ADD_PLUGIN([padlock],              [s charon])
 ADD_PLUGIN([openssl],              [s charon scepclient pki scripts manager medsrv attest nm cmd aikgen])
+ADD_PLUGIN([gmalg],                [s charon scepclient pki scripts manager medsrv attest nm cmd aikgen])
 ADD_PLUGIN([gcrypt],               [s charon scepclient pki scripts manager medsrv attest nm cmd aikgen])
 ADD_PLUGIN([af-alg],               [s charon scepclient pki scripts medsrv attest nm cmd aikgen])
 ADD_PLUGIN([fips-prf],             [s charon nm cmd])
@@ -1580,6 +1600,7 @@ AM_CONDITIONAL(USE_MYSQL, test x$mysql = xtrue)
 AM_CONDITIONAL(USE_SQLITE, test x$sqlite = xtrue)
 AM_CONDITIONAL(USE_PADLOCK, test x$padlock = xtrue)
 AM_CONDITIONAL(USE_OPENSSL, test x$openssl = xtrue)
+AM_CONDITIONAL(USE_GMALG, test x$gmalg = xtrue)
 AM_CONDITIONAL(USE_GCRYPT, test x$gcrypt = xtrue)
 AM_CONDITIONAL(USE_AGENT, test x$agent = xtrue)
 AM_CONDITIONAL(USE_KEYCHAIN, test x$keychain = xtrue)
@@ -1859,6 +1880,7 @@ AC_CONFIG_FILES([
 	src/libstrongswan/plugins/sqlite/Makefile
 	src/libstrongswan/plugins/padlock/Makefile
 	src/libstrongswan/plugins/openssl/Makefile
+	src/libstrongswan/plugins/gmalg/Makefile
 	src/libstrongswan/plugins/gcrypt/Makefile
 	src/libstrongswan/plugins/agent/Makefile
 	src/libstrongswan/plugins/keychain/Makefile
diff --git a/src/libcharon/encoding/payloads/proposal_substructure.c b/src/libcharon/encoding/payloads/proposal_substructure.c
index 415417566..3b1e57767 100644
--- a/src/libcharon/encoding/payloads/proposal_substructure.c
+++ b/src/libcharon/encoding/payloads/proposal_substructure.c
@@ -171,6 +171,8 @@ typedef enum {
 	IKEV1_ENCR_CAST_CBC = 6,
 	IKEV1_ENCR_AES_CBC = 7,
 	IKEV1_ENCR_CAMELLIA_CBC = 8,
+	IKEV1_ENCR_SM1_CBC = 9,
+	IKEV1_ENCR_SM4_CBC = 10,
 	/* FreeS/WAN proprietary */
 	IKEV1_ENCR_SERPENT_CBC = 65004,
 	IKEV1_ENCR_TWOFISH_CBC = 65005,
@@ -186,6 +188,7 @@ typedef enum {
 	IKEV1_HASH_SHA2_256 = 4,
 	IKEV1_HASH_SHA2_384 = 5,
 	IKEV1_HASH_SHA2_512 = 6,
+	IKEV1_HASH_SM3 = 7,
 } ikev1_hash_t;
 
 /**
@@ -221,6 +224,8 @@ typedef enum {
 	IKEV1_ESP_ENCR_SEED_CBC = 21,
 	IKEV1_ESP_ENCR_CAMELLIA = 22,
 	IKEV1_ESP_ENCR_NULL_AUTH_AES_GMAC = 23,
+	IKEV1_ESP_ENCR_SM1 = 24,
+	IKEV1_ESP_ENCR_SM4 = 25,
 	/* FreeS/WAN proprietary */
 	IKEV1_ESP_ENCR_SERPENT = 252,
 	IKEV1_ESP_ENCR_TWOFISH = 253,
@@ -242,6 +247,7 @@ typedef enum {
 	IKEV1_AH_AES_128_GMAC = 11,
 	IKEV1_AH_AES_192_GMAC = 12,
 	IKEV1_AH_AES_256_GMAC = 13,
+	IKEV1_AH_HMAC_SM3 = 14,
 } ikev1_ah_transid_t;
 
 /**
@@ -261,6 +267,7 @@ typedef enum {
 	IKEV1_AUTH_AES_128_GMAC = 11,
 	IKEV1_AUTH_AES_192_GMAC = 12,
 	IKEV1_AUTH_AES_256_GMAC = 13,
+	IKEV1_AUTH_HMAC_SM3 = 14,
 } ikev1_auth_algo_t;
 
 /**
@@ -295,6 +302,7 @@ typedef enum {
 	IKEV1_AUTH_ECDSA_256 = 9,
 	IKEV1_AUTH_ECDSA_384 = 10,
 	IKEV1_AUTH_ECDSA_521 = 11,
+	IKEV1_AUTH_SM2 = 12,
 	/* XAuth Modes */
 	IKEV1_AUTH_XAUTH_INIT_PSK = 65001,
 	IKEV1_AUTH_XAUTH_RESP_PSK = 65002,
@@ -593,6 +601,8 @@ static algo_map_t map_encr[] = {
 	{ IKEV1_ENCR_CAMELLIA_CBC,	ENCR_CAMELLIA_CBC },
 	{ IKEV1_ENCR_SERPENT_CBC,	ENCR_SERPENT_CBC },
 	{ IKEV1_ENCR_TWOFISH_CBC,	ENCR_TWOFISH_CBC },
+	{ IKEV1_ENCR_SM1_CBC,		ENCR_SM1_CBC },
+	{ IKEV1_ENCR_SM4_CBC,		ENCR_SM4_CBC },
 };
 
 /**
@@ -604,6 +614,7 @@ static algo_map_t map_integ[] = {
 	{ IKEV1_HASH_SHA2_256,		AUTH_HMAC_SHA2_256_128 },
 	{ IKEV1_HASH_SHA2_384,		AUTH_HMAC_SHA2_384_192 },
 	{ IKEV1_HASH_SHA2_512,		AUTH_HMAC_SHA2_512_256 },
+	{ IKEV1_HASH_SM3,		AUTH_HMAC_SM3 },
 };
 
 /**
@@ -615,6 +626,7 @@ static algo_map_t map_prf[] = {
 	{ IKEV1_HASH_SHA2_256,		PRF_HMAC_SHA2_256 },
 	{ IKEV1_HASH_SHA2_384,		PRF_HMAC_SHA2_384 },
 	{ IKEV1_HASH_SHA2_512,		PRF_HMAC_SHA2_512 },
+	{ IKEV1_HASH_SM3,		PRF_HMAC_SM3 },
 };
 
 /**
@@ -643,6 +655,8 @@ static algo_map_t map_esp[] = {
 	{ IKEV1_ESP_ENCR_NULL_AUTH_AES_GMAC,	ENCR_NULL_AUTH_AES_GMAC },
 	{ IKEV1_ESP_ENCR_SERPENT,				ENCR_SERPENT_CBC },
 	{ IKEV1_ESP_ENCR_TWOFISH,				ENCR_TWOFISH_CBC },
+	{ IKEV1_ESP_ENCR_SM1,					ENCR_SM1_CBC },
+	{ IKEV1_ESP_ENCR_SM4,					ENCR_SM4_CBC },
 };
 
 /**
@@ -659,6 +673,7 @@ static algo_map_t map_ah[] = {
 	{ IKEV1_AH_AES_128_GMAC,	AUTH_AES_128_GMAC },
 	{ IKEV1_AH_AES_192_GMAC,	AUTH_AES_192_GMAC },
 	{ IKEV1_AH_AES_256_GMAC,	AUTH_AES_256_GMAC },
+	{ IKEV1_AH_HMAC_SM3,		AUTH_HMAC_SM3 },
 };
 
 /**
@@ -676,6 +691,7 @@ static algo_map_t map_auth[] = {
 	{ IKEV1_AUTH_AES_128_GMAC,		AUTH_AES_128_GMAC },
 	{ IKEV1_AUTH_AES_192_GMAC,		AUTH_AES_192_GMAC },
 	{ IKEV1_AUTH_AES_256_GMAC,		AUTH_AES_256_GMAC },
+	{ IKEV1_AUTH_HMAC_SM3,			AUTH_HMAC_SM3 },
 };
 
 /**
@@ -833,6 +849,8 @@ static uint16_t get_ikev1_auth(auth_method_t method)
 			return IKEV1_AUTH_ECDSA_384;
 		case AUTH_ECDSA_521:
 			return IKEV1_AUTH_ECDSA_521;
+		case AUTH_SM2:
+			return IKEV1_AUTH_SM2;
 		case AUTH_PSK:
 		default:
 			return IKEV1_AUTH_PSK;
@@ -1175,6 +1193,8 @@ METHOD(proposal_substructure_t, get_auth_method, auth_method_t,
 			return AUTH_ECDSA_384;
 		case IKEV1_AUTH_ECDSA_521:
 			return AUTH_ECDSA_521;
+		case IKEV1_AUTH_SM2:
+			return AUTH_SM2;
 		default:
 			return AUTH_NONE;
 	}
diff --git a/src/libcharon/plugins/kernel_netlink/kernel_netlink_ipsec.c b/src/libcharon/plugins/kernel_netlink/kernel_netlink_ipsec.c
index 1292e0895..a26ab40be 100644
--- a/src/libcharon/plugins/kernel_netlink/kernel_netlink_ipsec.c
+++ b/src/libcharon/plugins/kernel_netlink/kernel_netlink_ipsec.c
@@ -223,6 +223,11 @@ static kernel_algorithm_t encryption_algs[] = {
 	{ENCR_AES_GCM_ICV16,		"rfc4106(gcm(aes))"	},
 	{ENCR_NULL_AUTH_AES_GMAC,	"rfc4543(gcm(aes))"	},
 	{ENCR_CAMELLIA_CBC,			"cbc(camellia)"		},
+	{ENCR_SM1_ECB,			"ecb(sm4)"		},
+	{ENCR_SM1_CBC,			"cbc(sm4)"		},
+	{ENCR_SM4_ECB,			"ecb(sm4)"		},
+	{ENCR_SM4_CBC,			"cbc(sm4)"		},
+
 /*	{ENCR_CAMELLIA_CTR,			"***"				}, */
 /*	{ENCR_CAMELLIA_CCM_ICV8,	"***"				}, */
 /*	{ENCR_CAMELLIA_CCM_ICV12,	"***"				}, */
@@ -244,6 +249,7 @@ static kernel_algorithm_t integrity_algs[] = {
 	{AUTH_HMAC_SHA2_256_128,	"hmac(sha256)"		},
 	{AUTH_HMAC_SHA2_384_192,	"hmac(sha384)"		},
 	{AUTH_HMAC_SHA2_512_256,	"hmac(sha512)"		},
+	{AUTH_HMAC_SM3,			"hmac(sm3)"		},
 /*	{AUTH_DES_MAC,				"***"				}, */
 /*	{AUTH_KPDK_MD5,				"***"				}, */
 	{AUTH_AES_XCBC_96,			"xcbc(aes)"			},
diff --git a/src/libcharon/sa/authenticator.c b/src/libcharon/sa/authenticator.c
index b77c19d00..1af6c04e0 100644
--- a/src/libcharon/sa/authenticator.c
+++ b/src/libcharon/sa/authenticator.c
@@ -37,6 +37,7 @@ ENUM_NEXT(auth_method_names, AUTH_ECDSA_256, AUTH_DS, AUTH_DSS,
 	"ECDSA-521 signature",
 	"secure password method",
 	"NULL authentication",
+	"SM2 signature",
 	"digital signature");
 ENUM_NEXT(auth_method_names, AUTH_XAUTH_INIT_PSK, AUTH_HYBRID_RESP_RSA, AUTH_DS,
 	"XAuthInitPSK",
@@ -97,6 +98,7 @@ authenticator_t *authenticator_create_verifier(
 	}
 	switch (auth_payload->get_auth_method(auth_payload))
 	{
+		case AUTH_SM2:
 		case AUTH_RSA:
 		case AUTH_ECDSA_256:
 		case AUTH_ECDSA_384:
@@ -144,6 +146,10 @@ authenticator_t *authenticator_create_v1(ike_sa_t *ike_sa, bool initiator,
 			return (authenticator_t*)pubkey_v1_authenticator_create(ike_sa,
 										initiator, dh, dh_value, sa_payload,
 										id_payload, KEY_ECDSA);
+		case AUTH_SM2:
+			return (authenticator_t*)pubkey_v1_authenticator_create(ike_sa,
+										initiator, dh, dh_value, sa_payload,
+										id_payload, KEY_SM2);
 		case AUTH_HYBRID_INIT_RSA:
 		case AUTH_HYBRID_RESP_RSA:
 			return (authenticator_t*)hybrid_authenticator_create(ike_sa,
diff --git a/src/libcharon/sa/authenticator.h b/src/libcharon/sa/authenticator.h
index 58a8ca04f..020b1ca85 100644
--- a/src/libcharon/sa/authenticator.h
+++ b/src/libcharon/sa/authenticator.h
@@ -84,10 +84,15 @@ enum auth_method_t {
 	 */
 	AUTH_NULL = 13,
 
+	/**
+	 * Digital Signature as specified in sm2
+	 */
+	AUTH_SM2 = 14,
+
 	/**
 	 * Digital Signature as specified in RFC 7427
 	 */
-	AUTH_DS = 14,
+	AUTH_DS = 15,
 
 	/**
 	 * IKEv1 initiator XAUTH with PSK, outside of IANA range
diff --git a/src/libcharon/sa/ikev1/authenticators/pubkey_v1_authenticator.c b/src/libcharon/sa/ikev1/authenticators/pubkey_v1_authenticator.c
index 9e5833efc..8f8f1692a 100644
--- a/src/libcharon/sa/ikev1/authenticators/pubkey_v1_authenticator.c
+++ b/src/libcharon/sa/ikev1/authenticators/pubkey_v1_authenticator.c
@@ -84,6 +84,10 @@ METHOD(authenticator_t, build, status_t,
 	{
 		scheme = SIGN_ECDSA_WITH_NULL;
 	}
+	if (this->type == KEY_SM2)
+	{
+		scheme = SIGN_SM2_WITH_SM3;
+	}
 
 	id = this->ike_sa->get_my_id(this->ike_sa);
 	auth = this->ike_sa->get_auth_cfg(this->ike_sa, TRUE);
@@ -171,6 +175,10 @@ METHOD(authenticator_t, process, status_t,
 	{
 		scheme = SIGN_ECDSA_WITH_NULL;
 	}
+	if (this->type == KEY_SM2)
+	{
+		scheme = SIGN_SM2_WITH_SM3;
+	}
 
 	sig_payload = (hash_payload_t*)message->get_payload(message, PLV1_SIGNATURE);
 	if (!sig_payload)
diff --git a/src/libcharon/sa/ikev1/keymat_v1.c b/src/libcharon/sa/ikev1/keymat_v1.c
index 1de05b4ec..73fe3ba88 100644
--- a/src/libcharon/sa/ikev1/keymat_v1.c
+++ b/src/libcharon/sa/ikev1/keymat_v1.c
@@ -255,6 +255,8 @@ static uint16_t auth_to_prf(uint16_t alg)
 {
 	switch (alg)
 	{
+		case AUTH_HMAC_SM3:
+			return PRF_HMAC_SM3;
 		case AUTH_HMAC_SHA1_96:
 			return PRF_HMAC_SHA1;
 		case AUTH_HMAC_SHA2_256_128:
@@ -279,6 +281,8 @@ static uint16_t auth_to_hash(uint16_t alg)
 {
 	switch (alg)
 	{
+		case AUTH_HMAC_SM3:
+			return HASH_SM3;
 		case AUTH_HMAC_SHA1_96:
 			return HASH_SHA1;
 		case AUTH_HMAC_SHA2_256_128:
@@ -385,6 +389,7 @@ METHOD(keymat_v1_t, derive_ike_keys, bool,
 			break;
 		}
 		case AUTH_RSA:
+		case AUTH_SM2:
 		case AUTH_ECDSA_256:
 		case AUTH_ECDSA_384:
 		case AUTH_ECDSA_521:
diff --git a/src/libcharon/sa/ikev1/phase1.c b/src/libcharon/sa/ikev1/phase1.c
index 5856f829e..ed2c68e6a 100644
--- a/src/libcharon/sa/ikev1/phase1.c
+++ b/src/libcharon/sa/ikev1/phase1.c
@@ -426,6 +426,9 @@ static auth_method_t get_pubkey_method(private_phase1_t *this, auth_cfg_t *auth)
 					case KEY_RSA:
 						method = AUTH_RSA;
 						break;
+					case KEY_SM2:
+						method = AUTH_SM2;
+						break;
 					case KEY_ECDSA:
 						switch (private->get_keysize(private))
 						{
@@ -534,6 +537,7 @@ static bool check_auth_method(private_phase1_t *this, peer_cfg_t *peer_cfg,
 	method = calc_auth_method(this, peer_cfg);
 	switch (given)
 	{
+		case AUTH_SM2:
 		case AUTH_ECDSA_256:
 		case AUTH_ECDSA_384:
 		case AUTH_ECDSA_521:
diff --git a/src/libcharon/sa/ikev1/tasks/isakmp_cert_post.c b/src/libcharon/sa/ikev1/tasks/isakmp_cert_post.c
index 7dbbdc92f..2b664acd2 100644
--- a/src/libcharon/sa/ikev1/tasks/isakmp_cert_post.c
+++ b/src/libcharon/sa/ikev1/tasks/isakmp_cert_post.c
@@ -75,6 +75,7 @@ static bool use_certs(private_isakmp_cert_post_t *this, message_t *message)
 			switch (sa_payload->get_auth_method(sa_payload))
 			{
 				case AUTH_RSA:
+				case AUTH_SM2:
 				case AUTH_ECDSA_256:
 				case AUTH_ECDSA_384:
 				case AUTH_ECDSA_521:
diff --git a/src/libcharon/sa/ikev1/tasks/isakmp_cert_pre.c b/src/libcharon/sa/ikev1/tasks/isakmp_cert_pre.c
index 58f856e3f..615728f95 100644
--- a/src/libcharon/sa/ikev1/tasks/isakmp_cert_pre.c
+++ b/src/libcharon/sa/ikev1/tasks/isakmp_cert_pre.c
@@ -416,6 +416,7 @@ static bool use_certs(private_isakmp_cert_pre_t *this, message_t *message)
 					}
 					/* FALL */
 				case AUTH_RSA:
+				case AUTH_SM2:
 				case AUTH_ECDSA_256:
 				case AUTH_ECDSA_384:
 				case AUTH_ECDSA_521:
diff --git a/src/libcharon/sa/keymat.c b/src/libcharon/sa/keymat.c
index 70521b5dc..d1e6376b7 100644
--- a/src/libcharon/sa/keymat.c
+++ b/src/libcharon/sa/keymat.c
@@ -95,6 +95,7 @@ int keymat_get_keylen_integ(integrity_algorithm_t alg)
 		{AUTH_HMAC_SHA2_512_256,	512},
 		{AUTH_AES_XCBC_96,			128},
 		{AUTH_AES_CMAC_96,			128},
+		{AUTH_HMAC_SM3,			256},
 	};
 	int i;
 
diff --git a/src/libstrongswan/Android.mk b/src/libstrongswan/Android.mk
index fb7c62a8a..d43fe436e 100644
--- a/src/libstrongswan/Android.mk
+++ b/src/libstrongswan/Android.mk
@@ -100,6 +100,12 @@ LOCAL_C_INCLUDES += $(openssl_PATH)
 LOCAL_STATIC_LIBRARIES += libcrypto_static
 endif
 
+LOCAL_SRC_FILES += $(call add_plugin, gmsdf)
+ifneq ($(call plugin_enabled, gmsdf),)
+LOCAL_C_INCLUDES += $(gmsdf_PATH)
+LOCAL_STATIC_LIBRARIES += libgmsdf_static
+endif
+
 LOCAL_SRC_FILES += $(call add_plugin, pem)
 
 LOCAL_SRC_FILES += $(call add_plugin, pkcs1)
diff --git a/src/libstrongswan/Makefile.am b/src/libstrongswan/Makefile.am
index 66539a879..3463adb81 100644
--- a/src/libstrongswan/Makefile.am
+++ b/src/libstrongswan/Makefile.am
@@ -558,6 +558,13 @@ if MONOLITHIC
 endif
 endif
 
+if USE_GMALG
+  SUBDIRS += plugins/gmalg
+if MONOLITHIC
+  libstrongswan_la_LIBADD += plugins/gmsdf/libstrongswan-gmalg.la
+endif
+endif
+
 if USE_GCRYPT
   SUBDIRS += plugins/gcrypt
 if MONOLITHIC
diff --git a/src/libstrongswan/asn1/oid.txt b/src/libstrongswan/asn1/oid.txt
index 723cb36fc..ca26b7d0e 100644
--- a/src/libstrongswan/asn1/oid.txt
+++ b/src/libstrongswan/asn1/oid.txt
@@ -69,6 +69,23 @@
     0x37                     "targetInformation"		OID_TARGET_INFORMATION
     0x38                     "noRevAvail"				OID_NO_REV_AVAIL
 0x2A                         ""
+  0x81                       ""
+    0x1c                     "ISO-CN"
+      0xcf                   ""
+        0x55                 "oscca"
+          0x01               "sm-scheme"
+            0x66             "sm1"
+              0x01           "sm1-ecb"                          OID_SM1_ECB
+              0x02           "sm1-cbc"                          OID_SM1_CBC
+            0x68             "sm4"
+              0x01           "sm4-ecb"                          OID_SM4_ECB
+              0x02           "sm4-cbc"                          OID_SM4_CBC
+            0x82             ""
+              0x2d           "sm2"				OID_SM2
+            0x83             ""
+              0x11           "sm3"
+                0x01         "hash-sm3"				OID_SM3
+              0x75           "sm2signsm3"			OID_SM2_WITH_SM3
   0x83                       ""
     0x08                     "jp"
       0x8C                   ""
diff --git a/src/libstrongswan/credentials/keys/public_key.c b/src/libstrongswan/credentials/keys/public_key.c
index 89fa9b348..dc0dedb61 100644
--- a/src/libstrongswan/credentials/keys/public_key.c
+++ b/src/libstrongswan/credentials/keys/public_key.c
@@ -27,6 +27,7 @@ ENUM(key_type_names, KEY_ANY, KEY_BLISS,
 	"DSA",
 	"ED25519",
 	"ED448",
+	"SM2",
 	"BLISS"
 );
 
@@ -60,6 +61,7 @@ ENUM(signature_scheme_names, SIGN_UNKNOWN, SIGN_BLISS_WITH_SHA3_512,
 	"BLISS_WITH_SHA3_256",
 	"BLISS_WITH_SHA3_384",
 	"BLISS_WITH_SHA3_512",
+	"SM2_WITH_SM2",
 );
 
 ENUM(encryption_scheme_names, ENCRYPT_UNKNOWN, ENCRYPT_RSA_OAEP_SHA512,
@@ -122,6 +124,9 @@ signature_scheme_t signature_scheme_from_oid(int oid)
 {
 	switch (oid)
 	{
+		case OID_SM2_WITH_SM3:
+		case OID_SM3:
+			return SIGN_SM2_WITH_SM3;
 		case OID_MD5_WITH_RSA:
 		case OID_MD5:
 			return SIGN_RSA_EMSA_PKCS1_MD5;
@@ -240,6 +245,8 @@ int signature_scheme_to_oid(signature_scheme_t scheme)
 			return OID_BLISS_WITH_SHA3_384;
 		case SIGN_BLISS_WITH_SHA3_512:
 			return OID_BLISS_WITH_SHA3_512;
+		case SIGN_SM2_WITH_SM3:
+			return OID_SM2_WITH_SM3;
 	}
 	return OID_UNKNOWN;
 }
@@ -281,6 +288,7 @@ static struct {
 	{ KEY_BLISS, 128, { .scheme = SIGN_BLISS_WITH_SHA2_256 }},
 	{ KEY_BLISS, 192, { .scheme = SIGN_BLISS_WITH_SHA2_384 }},
 	{ KEY_BLISS,   0, { .scheme = SIGN_BLISS_WITH_SHA2_512 }},
+	{ KEY_SM2,   256, { .scheme = SIGN_SM2_WITH_SM3 }},
 };
 
 /**
@@ -376,6 +384,8 @@ key_type_t key_type_from_signature_scheme(signature_scheme_t scheme)
 		case SIGN_BLISS_WITH_SHA3_384:
 		case SIGN_BLISS_WITH_SHA3_512:
 			return KEY_BLISS;
+		case SIGN_SM2_WITH_SM3:
+			return KEY_SM2;
 	}
 	return KEY_ANY;
 }
diff --git a/src/libstrongswan/credentials/keys/public_key.h b/src/libstrongswan/credentials/keys/public_key.h
index a98a33d20..5bc10d039 100644
--- a/src/libstrongswan/credentials/keys/public_key.h
+++ b/src/libstrongswan/credentials/keys/public_key.h
@@ -47,8 +47,9 @@ enum key_type_t {
 	KEY_ED25519 = 4,
 	/** Ed448   PureEdDSA instance as in RFC 8032 */
 	KEY_ED448   = 5,
+	KEY_SM2   = 6,
 	/** BLISS */
-	KEY_BLISS = 6,
+	KEY_BLISS = 7,
 };
 
 /**
@@ -122,6 +123,7 @@ enum signature_scheme_t {
 	SIGN_BLISS_WITH_SHA3_384,
 	/** BLISS with SHA-3_512                                           */
 	SIGN_BLISS_WITH_SHA3_512,
+	SIGN_SM2_WITH_SM3,
 };
 
 /**
diff --git a/src/libstrongswan/crypto/crypters/crypter.c b/src/libstrongswan/crypto/crypters/crypter.c
index 9bde663d1..8084ae155 100644
--- a/src/libstrongswan/crypto/crypters/crypter.c
+++ b/src/libstrongswan/crypto/crypters/crypter.c
@@ -46,6 +46,10 @@ ENUM_NEXT(encryption_algorithm_names, ENCR_CAMELLIA_CBC, ENCR_CHACHA20_POLY1305,
 	"CAMELLIA_CCM_8",
 	"CAMELLIA_CCM_12",
 	"CAMELLIA_CCM_16",
+	"SM1_ECB",
+	"SM1_CBC",
+	"SM4_ECB",
+	"SM4_CBC",
 	"CHACHA20_POLY1305");
 ENUM_NEXT(encryption_algorithm_names, ENCR_UNDEFINED, ENCR_RC2_CBC, ENCR_CHACHA20_POLY1305,
 	"UNDEFINED",
@@ -65,6 +69,22 @@ encryption_algorithm_t encryption_algorithm_from_oid(int oid, size_t *key_size)
 
 	switch (oid)
 	{
+		case OID_SM1_ECB:
+			alg = ENCR_SM1_ECB;
+			alg_key_size = 16 ;
+			break;
+		case OID_SM1_CBC:
+			alg = ENCR_SM1_CBC;
+			alg_key_size = 16 ;
+			break;
+		case OID_SM4_ECB:
+			alg = ENCR_SM4_ECB;
+			alg_key_size = 16 ;
+			break;
+		case OID_SM4_CBC:
+			alg = ENCR_SM4_CBC;
+			alg_key_size = 16 ;
+			break;
 		case OID_DES_CBC:
 			alg = ENCR_DES;
 			alg_key_size = 0;
@@ -121,6 +141,18 @@ int encryption_algorithm_to_oid(encryption_algorithm_t alg, size_t key_size)
 
 	switch(alg)
 	{
+		case ENCR_SM1_ECB:
+			oid = OID_SM1_ECB;
+			break;
+		case ENCR_SM1_CBC:
+			oid = OID_SM1_CBC;
+			break;
+		case ENCR_SM4_ECB:
+			oid = OID_SM4_ECB;
+			break;
+		case ENCR_SM4_CBC:
+			oid = OID_SM4_CBC;
+			break;
 		case ENCR_DES:
 			oid = OID_DES_CBC;
 			break;
diff --git a/src/libstrongswan/crypto/crypters/crypter.h b/src/libstrongswan/crypto/crypters/crypter.h
index 5ffcac253..242d5e725 100644
--- a/src/libstrongswan/crypto/crypters/crypter.h
+++ b/src/libstrongswan/crypto/crypters/crypter.h
@@ -57,7 +57,11 @@ enum encryption_algorithm_t {
 	ENCR_CAMELLIA_CCM_ICV8 =  25,
 	ENCR_CAMELLIA_CCM_ICV12 = 26,
 	ENCR_CAMELLIA_CCM_ICV16 = 27,
-	ENCR_CHACHA20_POLY1305 =  28,
+	ENCR_SM1_ECB            = 28,
+	ENCR_SM1_CBC            = 29,
+	ENCR_SM4_ECB            = 30,
+	ENCR_SM4_CBC            = 31,
+	ENCR_CHACHA20_POLY1305 =  32,
 	ENCR_UNDEFINED =        1024,
 	ENCR_DES_ECB =          1025,
 	ENCR_SERPENT_CBC =      1026,
@@ -72,6 +76,7 @@ enum encryption_algorithm_t {
 #define CAMELLIA_BLOCK_SIZE		16
 #define SERPENT_BLOCK_SIZE		16
 #define TWOFISH_BLOCK_SIZE		16
+#define SM14_BLOCK_SIZE			16
 
 /**
  * For RC2, if the effective key size in bits is not key_size * 8, it should
diff --git a/src/libstrongswan/crypto/diffie_hellman.c b/src/libstrongswan/crypto/diffie_hellman.c
index efcfdbc74..a35765173 100644
--- a/src/libstrongswan/crypto/diffie_hellman.c
+++ b/src/libstrongswan/crypto/diffie_hellman.c
@@ -43,6 +43,7 @@ ENUM_NEXT(diffie_hellman_group_names, MODP_1024_160, CURVE_448, ECP_521_BIT,
 	"ECP_384_BP",
 	"ECP_512_BP",
 	"CURVE_25519",
+	"CURVE_SM2",
 	"CURVE_448");
 ENUM_NEXT(diffie_hellman_group_names, MODP_NULL, MODP_NULL, CURVE_448,
 	"MODP_NULL");
@@ -493,6 +494,7 @@ bool diffie_hellman_group_is_ec(diffie_hellman_group_t group)
 		case ECP_256_BP:
 		case ECP_384_BP:
 		case ECP_512_BP:
+		case CURVE_SM2:
 			return TRUE;
 		default:
 			return FALSE;
@@ -550,6 +552,9 @@ bool diffie_hellman_verify_value(diffie_hellman_group_t group, chunk_t value)
 		case CURVE_25519:
 			valid = value.len == 32;
 			break;
+		case CURVE_SM2:
+			valid = value.len == 64;
+			break;
 		case CURVE_448:
 			valid = value.len == 56;
 			break;
diff --git a/src/libstrongswan/crypto/diffie_hellman.h b/src/libstrongswan/crypto/diffie_hellman.h
index ce01bb346..0bf2ab18e 100644
--- a/src/libstrongswan/crypto/diffie_hellman.h
+++ b/src/libstrongswan/crypto/diffie_hellman.h
@@ -62,7 +62,8 @@ enum diffie_hellman_group_t {
 	ECP_384_BP    = 29,
 	ECP_512_BP    = 30,
 	CURVE_25519   = 31,
-	CURVE_448     = 32,
+	CURVE_SM2     = 32,
+	CURVE_448     = 33,
 	/** insecure NULL diffie hellman group for testing, in PRIVATE USE */
 	MODP_NULL = 1024,
 	/** MODP group with custom generator/prime */
diff --git a/src/libstrongswan/crypto/hashers/hasher.c b/src/libstrongswan/crypto/hashers/hasher.c
index 2bd55ad2e..f2e490519 100644
--- a/src/libstrongswan/crypto/hashers/hasher.c
+++ b/src/libstrongswan/crypto/hashers/hasher.c
@@ -26,6 +26,7 @@ ENUM_BEGIN(hash_algorithm_names, HASH_SHA1, HASH_IDENTITY,
 	"HASH_SHA2_256",
 	"HASH_SHA2_384",
 	"HASH_SHA2_512",
+	"HASH_SM3",
 	"HASH_IDENTITY");
 ENUM_NEXT(hash_algorithm_names, HASH_UNKNOWN, HASH_SHA3_512, HASH_IDENTITY,
 	"HASH_UNKNOWN",
@@ -44,6 +45,7 @@ ENUM_BEGIN(hash_algorithm_short_names, HASH_SHA1, HASH_IDENTITY,
 	"sha256",
 	"sha384",
 	"sha512",
+	"sm3",
 	"identity");
 ENUM_NEXT(hash_algorithm_short_names, HASH_UNKNOWN, HASH_SHA3_512, HASH_IDENTITY,
 	"unknown",
@@ -62,6 +64,7 @@ ENUM_BEGIN(hash_algorithm_short_names_upper, HASH_SHA1, HASH_IDENTITY,
 	"SHA2_256",
 	"SHA2_384",
 	"SHA2_512",
+	"SM3",
 	"IDENTITY");
 ENUM_NEXT(hash_algorithm_short_names_upper, HASH_UNKNOWN, HASH_SHA3_512, HASH_IDENTITY,
 	"UNKNOWN",
@@ -82,6 +85,8 @@ size_t hasher_hash_size(hash_algorithm_t alg)
 {
 	switch (alg)
 	{
+		case HASH_SM3:
+			return HASH_SIZE_SM3;
 		case HASH_SHA1:
 			return HASH_SIZE_SHA1;
 		case HASH_SHA256:
@@ -156,6 +161,9 @@ hash_algorithm_t hasher_algorithm_from_oid(int oid)
 		case OID_ED25519:
 		case OID_ED448:
 			return HASH_IDENTITY;
+		case OID_SM3:
+		case OID_SM2_WITH_SM3:
+			return HASH_SM3;
 		default:
 			return HASH_UNKNOWN;
 	}
@@ -168,6 +176,8 @@ hash_algorithm_t hasher_algorithm_from_prf(pseudo_random_function_t alg)
 {
 	switch (alg)
 	{
+		case PRF_HMAC_SM3:
+			return HASH_SM3;
 		case PRF_HMAC_MD5:
 			return HASH_MD5;
 		case PRF_HMAC_SHA1:
@@ -219,6 +229,7 @@ hash_algorithm_t hasher_algorithm_from_integrity(integrity_algorithm_t alg,
 				break;
 			case AUTH_HMAC_SHA2_256_256:
 			case AUTH_HMAC_SHA2_512_256:
+			case AUTH_HMAC_SM3:
 				*length = 32;
 				break;
 			case AUTH_HMAC_SHA2_384_384:
@@ -233,6 +244,8 @@ hash_algorithm_t hasher_algorithm_from_integrity(integrity_algorithm_t alg,
 	}
 	switch (alg)
 	{
+		case AUTH_HMAC_SM3:
+			return HASH_SM3;
 		case AUTH_HMAC_MD5_96:
 		case AUTH_HMAC_MD5_128:
 		case AUTH_KPDK_MD5:
@@ -272,6 +285,8 @@ integrity_algorithm_t hasher_algorithm_to_integrity(hash_algorithm_t alg,
 {
 	switch (alg)
 	{
+		case HASH_SM3:
+			return AUTH_HMAC_SM3;
 		case HASH_MD5:
 			switch (length)
 			{
@@ -347,6 +362,7 @@ bool hasher_algorithm_for_ikev2(hash_algorithm_t alg)
 		case HASH_SHA256:
 		case HASH_SHA384:
 		case HASH_SHA512:
+		case HASH_SM3:
 			return TRUE;
 		case HASH_UNKNOWN:
 		case HASH_MD2:
@@ -372,6 +388,9 @@ int hasher_algorithm_to_oid(hash_algorithm_t alg)
 
 	switch (alg)
 	{
+		case HASH_SM3:
+			oid = OID_SM3;
+			break;
 		case HASH_MD2:
 			oid = OID_MD2;
 			break;
@@ -418,6 +437,14 @@ int hasher_signature_algorithm_to_oid(hash_algorithm_t alg, key_type_t key)
 {
 	switch (key)
 	{
+		case KEY_SM2:
+			switch (alg)
+			{
+				case HASH_SM3:
+					return OID_SM2_WITH_SM3;
+				default:
+					return OID_UNKNOWN;
+			}
 		case KEY_RSA:
 			switch (alg)
 			{
@@ -554,6 +581,8 @@ hash_algorithm_t hasher_from_signature_scheme(signature_scheme_t scheme,
 		case SIGN_RSA_EMSA_PKCS1_SHA3_512:
 		case SIGN_BLISS_WITH_SHA3_512:
 			return HASH_SHA3_512;
+		case SIGN_SM2_WITH_SM3:
+			return HASH_SM3;
 	}
 	return HASH_UNKNOWN;
 }
diff --git a/src/libstrongswan/crypto/hashers/hasher.h b/src/libstrongswan/crypto/hashers/hasher.h
index f4f57d917..c06037a04 100644
--- a/src/libstrongswan/crypto/hashers/hasher.h
+++ b/src/libstrongswan/crypto/hashers/hasher.h
@@ -40,8 +40,9 @@ enum hash_algorithm_t {
 	HASH_SHA256			= 2,
 	HASH_SHA384			= 3,
 	HASH_SHA512			= 4,
+	HASH_SM3			= 5,
 	/* RFC 8420 */
-	HASH_IDENTITY		= 5,
+	HASH_IDENTITY		= 6,
 	/* use private use range for algorithms not defined/permitted by RFC 7427 */
 	HASH_UNKNOWN 		= 1024,
 	HASH_MD2 			= 1025,
@@ -62,6 +63,7 @@ enum hash_algorithm_t {
 #define HASH_SIZE_SHA256	32
 #define HASH_SIZE_SHA384	48
 #define HASH_SIZE_SHA512	64
+#define HASH_SIZE_SM3		32
 
 /**
  * enum names for hash_algorithm_t.
diff --git a/src/libstrongswan/crypto/iv/iv_gen.c b/src/libstrongswan/crypto/iv/iv_gen.c
index c6efe08d0..dbe2c622f 100644
--- a/src/libstrongswan/crypto/iv/iv_gen.c
+++ b/src/libstrongswan/crypto/iv/iv_gen.c
@@ -28,6 +28,10 @@ iv_gen_t* iv_gen_create_for_alg(encryption_algorithm_t alg)
 {
 	switch (alg)
 	{
+		case ENCR_SM1_ECB:
+		case ENCR_SM1_CBC:
+		case ENCR_SM4_ECB:
+		case ENCR_SM4_CBC:
 		case ENCR_DES:
 		case ENCR_3DES:
 		case ENCR_RC5:
diff --git a/src/libstrongswan/crypto/prfs/prf.c b/src/libstrongswan/crypto/prfs/prf.c
index eee09535d..b85c3e2f5 100644
--- a/src/libstrongswan/crypto/prfs/prf.c
+++ b/src/libstrongswan/crypto/prfs/prf.c
@@ -33,6 +33,7 @@ ENUM_NEXT(pseudo_random_function_names, PRF_HMAC_MD5, PRF_AES128_CMAC, PRF_CAMEL
 	"PRF_HMAC_SHA2_256",
 	"PRF_HMAC_SHA2_384",
 	"PRF_HMAC_SHA2_512",
+	"PRF_HMAC_SM3",
 	"PRF_AES128_CMAC");
 ENUM_END(pseudo_random_function_names, PRF_AES128_CMAC);
 
diff --git a/src/libstrongswan/crypto/prfs/prf.h b/src/libstrongswan/crypto/prfs/prf.h
index a91de1ddc..b43fe12a1 100644
--- a/src/libstrongswan/crypto/prfs/prf.h
+++ b/src/libstrongswan/crypto/prfs/prf.h
@@ -51,7 +51,8 @@ enum pseudo_random_function_t {
 	/** RFC4868 */
 	PRF_HMAC_SHA2_512 = 7,
 	/** RFC4615 */
-	PRF_AES128_CMAC = 8,
+	PRF_HMAC_SM3 = 8,
+	PRF_AES128_CMAC = 9,
 	/** FIPS 186-2-change1 */
 	PRF_FIPS_SHA1_160 = 1025,
 	/** FIPS 186-2-change1, uses fixed output size of 160bit */
diff --git a/src/libstrongswan/crypto/proposal/proposal.c b/src/libstrongswan/crypto/proposal/proposal.c
index 952608997..a2b42c6ba 100644
--- a/src/libstrongswan/crypto/proposal/proposal.c
+++ b/src/libstrongswan/crypto/proposal/proposal.c
@@ -644,6 +644,7 @@ static const struct {
 	{AUTH_AES_XCBC_96,					PRF_AES128_XCBC					},
 	{AUTH_CAMELLIA_XCBC_96,				PRF_CAMELLIA128_XCBC			},
 	{AUTH_AES_CMAC_96,					PRF_AES128_CMAC					},
+	{AUTH_HMAC_SM3,					PRF_HMAC_SM3					},
 };
 
 /**
diff --git a/src/libstrongswan/crypto/proposal/proposal_keywords_static.txt b/src/libstrongswan/crypto/proposal/proposal_keywords_static.txt
index b214a9edf..4154aa904 100644
--- a/src/libstrongswan/crypto/proposal/proposal_keywords_static.txt
+++ b/src/libstrongswan/crypto/proposal/proposal_keywords_static.txt
@@ -110,6 +110,10 @@ camellia256ccm96, ENCRYPTION_ALGORITHM, ENCR_CAMELLIA_CCM_ICV12, 256
 camellia256ccm16, ENCRYPTION_ALGORITHM, ENCR_CAMELLIA_CCM_ICV16, 256
 camellia256ccm128,ENCRYPTION_ALGORITHM, ENCR_CAMELLIA_CCM_ICV16, 256
 cast128,          ENCRYPTION_ALGORITHM, ENCR_CAST,               128
+sm1ecb,           ENCRYPTION_ALGORITHM, ENCR_SM1_ECB,            128
+sm1cbc,           ENCRYPTION_ALGORITHM, ENCR_SM1_CBC,            128
+sm4ecb,           ENCRYPTION_ALGORITHM, ENCR_SM4_ECB,            128
+sm4cbc,           ENCRYPTION_ALGORITHM, ENCR_SM4_CBC,            128
 serpent,          ENCRYPTION_ALGORITHM, ENCR_SERPENT_CBC,        128
 serpent128,       ENCRYPTION_ALGORITHM, ENCR_SERPENT_CBC,        128
 serpent192,       ENCRYPTION_ALGORITHM, ENCR_SERPENT_CBC,        192
@@ -128,6 +132,7 @@ sha2_256_96,      INTEGRITY_ALGORITHM,  AUTH_HMAC_SHA2_256_96,     0
 sha384,           INTEGRITY_ALGORITHM,  AUTH_HMAC_SHA2_384_192,    0
 sha2_384,         INTEGRITY_ALGORITHM,  AUTH_HMAC_SHA2_384_192,    0
 sha512,           INTEGRITY_ALGORITHM,  AUTH_HMAC_SHA2_512_256,    0
+sm3,              INTEGRITY_ALGORITHM,  AUTH_HMAC_SM3,             0
 sha2_512,         INTEGRITY_ALGORITHM,  AUTH_HMAC_SHA2_512_256,    0
 md5,              INTEGRITY_ALGORITHM,  AUTH_HMAC_MD5_96,          0
 md5_128,          INTEGRITY_ALGORITHM,  AUTH_HMAC_MD5_128,         0
@@ -142,6 +147,7 @@ prfmd5,           PSEUDO_RANDOM_FUNCTION, PRF_HMAC_MD5,            0
 prfaesxcbc,       PSEUDO_RANDOM_FUNCTION, PRF_AES128_XCBC,         0
 prfcamelliaxcbc,  PSEUDO_RANDOM_FUNCTION, PRF_CAMELLIA128_XCBC,    0
 prfaescmac,       PSEUDO_RANDOM_FUNCTION, PRF_AES128_CMAC,         0
+prfsm3,           PSEUDO_RANDOM_FUNCTION, PRF_HMAC_SM3,            0
 modpnone,         DIFFIE_HELLMAN_GROUP, MODP_NONE,                 0
 modpnull,         DIFFIE_HELLMAN_GROUP, MODP_NULL,                 0
 modp768,          DIFFIE_HELLMAN_GROUP, MODP_768_BIT,              0
@@ -166,6 +172,7 @@ ecp384bp,         DIFFIE_HELLMAN_GROUP, ECP_384_BP,                0
 ecp512bp,         DIFFIE_HELLMAN_GROUP, ECP_512_BP,                0
 curve25519,       DIFFIE_HELLMAN_GROUP, CURVE_25519,               0
 x25519,           DIFFIE_HELLMAN_GROUP, CURVE_25519,               0
+sm2dh,            DIFFIE_HELLMAN_GROUP, CURVE_SM2,                 0
 ntru112,          DIFFIE_HELLMAN_GROUP, NTRU_112_BIT,              0
 ntru128,          DIFFIE_HELLMAN_GROUP, NTRU_128_BIT,              0
 ntru192,          DIFFIE_HELLMAN_GROUP, NTRU_192_BIT,              0
diff --git a/src/libstrongswan/crypto/signers/signer.c b/src/libstrongswan/crypto/signers/signer.c
index 2ba38ad7f..f0bed8ae0 100644
--- a/src/libstrongswan/crypto/signers/signer.c
+++ b/src/libstrongswan/crypto/signers/signer.c
@@ -38,6 +38,7 @@ ENUM_NEXT(integrity_algorithm_names, AUTH_HMAC_MD5_96, AUTH_HMAC_SHA2_512_256, A
 	"AES_256_GMAC",
 	"HMAC_SHA2_256_128",
 	"HMAC_SHA2_384_192",
+	"HMAC_SM3",
 	"HMAC_SHA2_512_256");
 ENUM_END(integrity_algorithm_names, AUTH_HMAC_SHA2_512_256);
 
diff --git a/src/libstrongswan/crypto/signers/signer.h b/src/libstrongswan/crypto/signers/signer.h
index f0d6667ff..d7d4d08f7 100644
--- a/src/libstrongswan/crypto/signers/signer.h
+++ b/src/libstrongswan/crypto/signers/signer.h
@@ -62,7 +62,8 @@ enum integrity_algorithm_t {
 	/** RFC4868 */
 	AUTH_HMAC_SHA2_384_192 = 13,
 	/** RFC4868 */
-	AUTH_HMAC_SHA2_512_256 = 14,
+	AUTH_HMAC_SM3 = 14,
+	AUTH_HMAC_SHA2_512_256 = 15,
 	/** private use */
 	AUTH_HMAC_SHA1_128 = 1025,
 	/** SHA256 96 bit truncation variant, supported by Linux kernels */
diff --git a/src/libstrongswan/plugins/gmalg/Makefile.am b/src/libstrongswan/plugins/gmalg/Makefile.am
new file mode 100644
index 000000000..c01be3ae0
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/Makefile.am
@@ -0,0 +1,29 @@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/libstrongswan \
+	-I$(top_srcdir)/src/libstrongswan/plugins/gmalg/gmalg/private_include \
+	-I$(top_srcdir)/src/libstrongswan/plugins/gmalg/gmalg/include \
+	-DGMALG_INTERIOR=${gmalg_interior}
+
+AM_CFLAGS = \
+	$(PLUGIN_CFLAGS)
+
+if MONOLITHIC
+noinst_LTLIBRARIES = libstrongswan-gmalg.la
+else
+plugin_LTLIBRARIES = libstrongswan-gmalg.la
+endif
+
+libstrongswan_gmalg_la_SOURCES = \
+	gmalg_plugin.h gmalg_plugin.c \
+	gmalg_util.c gmalg_util.h \
+	gmalg_crypter.c gmalg_crypter.h \
+	gmalg_hasher.c gmalg_hasher.h \
+	gmalg_rng.c gmalg_rng.h \
+	gmalg_ec_diffie_hellman.c gmalg_ec_diffie_hellman.h\
+	gmalg_ec_private_key.c gmalg_ec_private_key.h \
+	gmalg_ec_public_key.c gmalg_ec_public_key.h \
+	gmalg/ecc.c gmalg/sm2.c gmalg/sm3.c gmalg/sm4.c \
+	gmalg/gmalg.c gmalg/random.c
+
+libstrongswan_gmalg_la_LDFLAGS = -module -avoid-version
+libstrongswan_gmalg_la_LIBADD  = $(GMALG_LIB)
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/README.md b/src/libstrongswan/plugins/gmalg/gmalg/README.md
new file mode 100644
index 000000000..2f1358aae
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/README.md
@@ -0,0 +1,2 @@
+# gmalg
+国密算法sm1，sm2，sm3，sm4算法源码 
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/debug.c b/src/libstrongswan/plugins/gmalg/gmalg/debug.c
new file mode 100644
index 000000000..979b05d89
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/debug.c
@@ -0,0 +1,58 @@
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include<time.h>
+
+void printHex(unsigned char *name, unsigned char *c, int n)
+{
+	int i;
+
+	#define  _print	printf
+
+	_print ("\n---------------------[%s ,len = %d, start ]----------------------\n",name,n);
+	for (i = 0; i < n; i++) {
+		_print("0x%02X, ", c[i]);
+		if ((i%4) == 3)
+		    _print(" ");
+
+		if ((i%16) == 15)
+		    _print("\n");
+	}
+	if ((i%16) != 0)
+		_print("\n");
+	_print("----------------------[%s       end        ]----------------------\n",name);
+}
+
+void speed_test( char *name, int len)
+{
+	static volatile unsigned long long byte = 0;
+	static volatile unsigned long long count = 0;
+	static time_t t1, t2;
+	static int flag = 0;
+
+	if (!flag) {
+		flag = 3;
+		time(&t1);
+	}
+
+	byte += len;
+	count++;
+
+	time(&t2);
+	if ((t2-t1) >= flag) {
+
+		unsigned long long byte_temp = byte;
+		unsigned long long count_temp = count;
+
+		if (byte_temp)
+			byte_temp = byte_temp*8/flag/1024/1024;
+
+		if (count_temp)
+			count_temp = count_temp/flag;
+
+		printf(" %s speed = %lld Mb, %lld Hz \n", name, byte_temp, count_temp);
+		t1 = t2;
+		byte = 0;
+		count = 0;
+	}
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/ecc.c b/src/libstrongswan/plugins/gmalg/gmalg/ecc.c
new file mode 100644
index 000000000..afee069cf
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/ecc.c
@@ -0,0 +1,809 @@
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <linux/swab.h>
+
+#include "debug.h"
+#include "ecc.h"
+
+extern struct ecc_curve ecc_curve;
+
+#if defined(__SIZEOF_INT128__) || ((__clang_major__ * 100 + __clang_minor__) >= 302)
+#define SUPPORTS_INT128 1
+#else
+#define SUPPORTS_INT128 0
+#endif
+
+#if SUPPORTS_INT128
+typedef unsigned __int128 uint128_t;
+#else
+typedef struct
+{
+	uint64_t m_low;
+	uint64_t m_high;
+} uint128_t;
+#endif
+
+void vli_clear(u8 *vli)
+{
+	int i;
+
+	for (i = 0; i < ECC_NUMWORD; ++i) {
+		vli[i] = 0;
+	}
+}
+
+/* Returns true if vli == 0, false otherwise. */
+int vli_is_zero(u8 *vli)
+{
+	int i;
+
+	for (i = 0; i < ECC_NUMWORD; ++i) {
+		if (vli[i])
+			return 0;
+	}
+
+	return 1;
+}
+
+/* Returns nonzero if bit bit of vli is set. */
+u8 vli_test_bit(u8 *vli, uint bit)
+{
+	return (vli[bit/8] & ((u8)1 << (bit % 8)));
+}
+
+/* Counts the number of 8-bit "digits" in vli. */
+u32 vli_num_digits(u8 *vli)
+{
+	int i;
+	/* Search from the end until we find a non-zero digit.
+	 * We do it in reverse because we expect that most digits will
+	 * be nonzero.
+	 */
+	for (i = ECC_NUMWORD - 1; i >= 0 && vli[i] == 0; --i);
+
+	return (i + 1);
+}
+
+/* Counts the number of bits required for vli. */
+u32 vli_num_bits(u8 *vli)
+{
+	u32 i, num_digits;
+	u8 digit;
+
+	num_digits = vli_num_digits(vli);
+	if (num_digits == 0)
+		return 0;
+
+	digit = vli[num_digits - 1];
+	for (i = 0; digit; ++i)
+		digit >>= 1;
+
+	return ((num_digits - 1) * 8 + i);
+}
+
+/* Sets dest = src. */
+void vli_set(u8 *dest, u8 *src)
+{
+	u32 i;
+
+	for (i = 0; i < ECC_NUMWORD; ++i)
+		dest[i] = src[i];
+}
+
+/* Returns sign of left - right. */
+int vli_cmp(u8 *left, u8 *right)
+{
+	int i;
+
+	for (i = ECC_NUMWORD - 1; i >= 0; --i) {
+		if (left[i] > right[i])
+			return 1;
+		else if (left[i] < right[i])
+			return -1;
+	}
+	return 0;
+}
+
+/* Computes result = in << c, returning carry. Can modify in place
+ * (if result == in). 0 < shift < 8.
+ */
+u8 vli_lshift(u8 *result, u8 *in, u32 shift)
+{
+	u8 carry = 0;
+	int i;
+
+	for (i = 0; i < ECC_NUMWORD; ++i) {
+		u8 temp = in[i];
+		result[i] = (temp << shift) | carry;
+		carry = temp >> (8 - shift);
+	}
+
+	return carry;
+}
+
+/* Computes vli = vli >> 1. */
+void vli_rshift1(u8 *vli)
+{
+	u8 *end = vli;
+	u8 carry = 0;
+
+	vli += ECC_NUMWORD;
+	while (vli-- > end)
+	{
+		u8 temp = *vli;
+		*vli = (temp >> 1) | carry;
+		carry = temp << 7;
+	}
+}
+
+/* Computes result = left + right, returning carry. Can modify in place. */
+u8 vli_add(u8 *result, u8 *left, u8 *right)
+{
+	u8 carry = 0;
+	u32 i;
+
+	for(i=0; i<ECC_NUMWORD; ++i){
+		u8 sum;
+
+		sum = left[i] + right[i] + carry;
+		if (sum != left[i]) {
+			carry = (sum < left[i]);
+		}
+		result[i] = sum;
+	}
+
+	return carry;
+}
+
+/* Computes result = left - right, returning borrow. Can modify in place. */
+u8 vli_sub(u8 *result, u8 *left, u8 *right)
+{
+	u8 borrow = 0;
+	int i;
+
+	for (i = 0; i < ECC_NUMWORD; ++i) {
+		u8 diff;
+
+		diff = left[i] - right[i] - borrow;
+		if (diff != left[i])
+			borrow = (diff > left[i]);
+
+		result[i] = diff;
+	}
+
+	return borrow;
+}
+
+/* Computes result = left * right. */
+void vli_mult(u8 *result, u8 *left, u8 *right)
+{
+	u16 r01 = 0;
+	u8 r2 = 0;
+	int i, k;
+
+	/* Compute each digit of result in sequence, maintaining the carries. */
+	for (k = 0; k < ECC_NUMWORD*2 - 1; ++k) {
+		int min = (k < ECC_NUMWORD ? 0 : (k + 1) - ECC_NUMWORD);
+		for (i = min; i <= k && i < ECC_NUMWORD; ++i) {
+			u16 product = (u16)left[i] * right[k-i];
+			r01 = r01 + product;
+			r2 += (r01 < product);
+		}
+		result[k] = (u8)r01;
+		r01 = (r01 >> 8) | (((u16)r2) << 8);
+		r2 = 0;
+	}
+
+	result[ECC_NUMWORD*2 - 1] = (u8)r01;
+}
+
+/* Computes result = left^2. */
+void vli_square(u8 *result, u8 *left)
+{
+	u16 r01 = 0;
+	u8 r2 = 0;
+	int i, k;
+
+	for (k = 0; k < ECC_NUMWORD*2 - 1; ++k) {
+		uint min = (k < ECC_NUMWORD ? 0 : (k + 1) - ECC_NUMWORD);
+		for (i = min; i <= k && i <= k - i; ++i) {
+			u16 product = (u16)left[i] * left[k-i];
+			if (i < k - i) {
+				r2 += product >> 15;
+				product *= 2;
+			}
+			r01 += product;
+			r2 += (r01 < product);
+		}
+		result[k] = (u8)r01;
+		r01 = (r01 >> 8) | (((u16)r2) << 8);
+		r2 = 0;
+	}
+
+	result[ECC_NUMWORD*2 - 1] = (u8)r01;
+}
+
+/* Computes result = (left + right) % mod.
+   Assumes that left < mod and right < mod, result != mod. */
+void vli_mod_add(u8 *result, u8 *left, u8 *right, u8 *mod)
+{
+	u8 carry;
+
+	carry = vli_add(result, left, right);
+	/* result > mod (result = mod + remainder), so subtract mod to
+	 * get remainder.
+	 */
+
+	if(carry || vli_cmp(result, mod) >= 0) {
+		/* result > mod (result = mod + remainder), so subtract mod to get remainder. */
+		vli_sub(result, result, mod);
+	}
+}
+
+/* Computes result = (left - right) % mod.
+   Assumes that left < mod and right < mod, result != mod. */
+void vli_mod_sub(u8 *result, u8 *left, u8 *right, u8 *mod)
+{
+	u8 borrow;
+
+	borrow = vli_sub(result, left, right);
+	/* In this case, result == -diff == (max int) - diff.
+	 * Since -x % d == d - x, we can get the correct result from
+	 * result + mod (with overflow).
+	 */
+	if(borrow)
+		vli_add(result, result, mod);
+}
+
+void vli_mmod_fast(u8 *result, u8 *product, u8* mod)
+{
+	u8 tmp1[ECC_NUMWORD];
+	u8 tmp2[ECC_NUMWORD];
+	u8 tmp3[ECC_NUMWORD];
+	int carry = 0;
+
+	vli_set(result, product);
+	vli_clear(tmp1);
+	vli_clear(tmp2);
+	vli_clear(tmp3);
+
+	/* Y0 */
+	tmp1[0] = tmp1[12] = tmp1[28] = product[32];
+	tmp1[1] = tmp1[13] = tmp1[29] = product[33];
+	tmp1[2] = tmp1[14] = tmp1[30] = product[34];
+	tmp1[3] = tmp1[15] = tmp1[31] = product[35];
+	tmp2[8] = product[32];
+	tmp2[9] = product[33];
+	tmp2[10] = product[34];
+	tmp2[11] = product[35];
+	carry += vli_add(result, result, tmp1);
+	carry -= vli_sub(result, result, tmp2);
+
+	/* Y1 */
+	tmp1[0] = tmp1[4] = tmp1[16] = tmp1[28] = product[36];
+	tmp1[1] = tmp1[5] = tmp1[17] = tmp1[29] = product[37];
+	tmp1[2] = tmp1[6] = tmp1[18] = tmp1[30] = product[38];
+	tmp1[3] = tmp1[7] = tmp1[19] = tmp1[31] = product[39];
+	tmp1[12] = tmp1[13] = tmp1[14] = tmp1[15] = 0;
+	tmp2[8] = product[36];
+	tmp2[9] = product[37];
+	tmp2[10] = product[38];
+	tmp2[11] = product[39];
+	carry += vli_add(result, result, tmp1);
+	carry -= vli_sub(result, result, tmp2);
+
+	/* Y2 */
+	tmp1[0] = tmp1[4] = tmp1[20] = tmp1[28] = product[40];
+	tmp1[1] = tmp1[5] = tmp1[21] = tmp1[29] = product[41];
+	tmp1[2] = tmp1[6] = tmp1[22] = tmp1[30] = product[42];
+	tmp1[3] = tmp1[7] = tmp1[23] = tmp1[31] = product[43];
+	tmp1[16] = tmp1[17] = tmp1[18] = tmp1[19] = 0;
+	carry += vli_add(result, result, tmp1);
+
+	/* Y3 */
+	tmp1[0] = tmp1[4] = tmp1[12] = tmp1[24] = tmp1[28] = product[44];
+	tmp1[1] = tmp1[5] = tmp1[13] = tmp1[25] = tmp1[29] = product[45];
+	tmp1[2] = tmp1[6] = tmp1[14] = tmp1[26] = tmp1[30] = product[46];
+	tmp1[3] = tmp1[7] = tmp1[15] = tmp1[27] = tmp1[31] = product[47];
+	tmp1[20] = tmp1[21] = tmp1[22] = tmp1[23] = 0;
+	carry += vli_add(result, result, tmp1);
+
+	/* Y4 */
+	tmp1[0] = tmp1[4] = tmp1[12] = tmp1[16] = tmp1[28] = tmp3[28] = product[48];
+	tmp1[1] = tmp1[5] = tmp1[13] = tmp1[17] = tmp1[29] = tmp3[29] = product[49];
+	tmp1[2] = tmp1[6] = tmp1[14] = tmp1[18] = tmp1[30] = tmp3[30] = product[50];
+	tmp1[3] = tmp1[7] = tmp1[15] = tmp1[19] = tmp1[31] = tmp3[31] = product[51];
+	tmp1[24] = tmp1[25] = tmp1[26] = tmp1[27] = 0;
+	carry += vli_add(result, result, tmp1);
+	carry += vli_add(result, result, tmp3);
+
+	/* Y5 */
+	tmp1[0] = tmp1[4] = tmp1[12] = tmp1[16] = tmp1[20] = tmp1[28] = product[52];
+	tmp1[1] = tmp1[5] = tmp1[13] = tmp1[17] = tmp1[21] = tmp1[29] = product[53];
+	tmp1[2] = tmp1[6] = tmp1[14] = tmp1[18] = tmp1[22] = tmp1[30] = product[54];
+	tmp1[3] = tmp1[7] = tmp1[15] = tmp1[19] = tmp1[23] = tmp1[31] = product[55];
+	tmp2[8] = product[52];
+	tmp2[9] = product[53];
+	tmp2[10] = product[54];
+	tmp2[11] = product[55];
+	tmp3[0] = tmp3[12] = tmp3[28] = product[52];
+	tmp3[1] = tmp3[13] = tmp3[29] = product[53];
+	tmp3[2] = tmp3[14] = tmp3[30] = product[54];
+	tmp3[3] = tmp3[15] = tmp3[31] = product[55];
+	carry += vli_add(result, result, tmp1);
+	carry += vli_add(result, result, tmp3);
+	carry -= vli_sub(result, result, tmp2);
+
+	/* Y6 */
+	tmp1[0] = tmp1[4] = tmp1[12] = tmp1[16] = tmp1[20] = tmp1[24] = tmp1[28] = product[56];
+	tmp1[1] = tmp1[5] = tmp1[13] = tmp1[17] = tmp1[21] = tmp1[25] = tmp1[29] = product[57];
+	tmp1[2] = tmp1[6] = tmp1[14] = tmp1[18] = tmp1[22] = tmp1[26] = tmp1[30] = product[58];
+	tmp1[3] = tmp1[7] = tmp1[15] = tmp1[19] = tmp1[23] = tmp1[27] = tmp1[31] = product[59];
+	tmp2[8] = product[56];
+	tmp2[9] = product[57];
+	tmp2[10] = product[58];
+	tmp2[11] = product[59];
+	tmp3[0] = tmp3[4] = tmp3[16] = tmp3[28] = product[56];
+	tmp3[1] = tmp3[5] = tmp3[17] = tmp3[29] = product[57];
+	tmp3[2] = tmp3[6] = tmp3[18] = tmp3[30] = product[58];
+	tmp3[3] = tmp3[7] = tmp3[19] = tmp3[31] = product[59];
+	tmp3[12] = tmp3[13] = tmp3[14] = tmp3[15] = 0;
+	carry += vli_add(result, result, tmp1);
+	carry += vli_add(result, result, tmp3);
+	carry -= vli_sub(result, result, tmp2);
+
+	/* Y7 */
+	tmp1[0] = tmp1[4] = tmp1[12] = tmp1[16] = tmp1[20] = tmp1[24] = tmp1[28] = product[60];
+	tmp1[1] = tmp1[5] = tmp1[13] = tmp1[17] = tmp1[21] = tmp1[25] = tmp1[29] = product[61];
+	tmp1[2] = tmp1[6] = tmp1[14] = tmp1[18] = tmp1[22] = tmp1[26] = tmp1[30] = product[62];
+	tmp1[3] = tmp1[7] = tmp1[15] = tmp1[19] = tmp1[23] = tmp1[27] = tmp1[31] = product[63];
+	tmp3[0] = tmp3[4] = tmp3[20]  = product[60];
+	tmp3[1] = tmp3[5] = tmp3[21]  = product[61];
+	tmp3[2] = tmp3[6] = tmp3[22]  = product[62];
+	tmp3[3] = tmp3[7] = tmp3[23]  = product[63];
+	tmp3[16] = tmp3[17] = tmp3[18] = tmp3[19] = tmp3[28] = tmp3[29] = tmp3[30] = tmp3[31] = 0;
+	tmp2[28] = product[60];
+	tmp2[29] = product[61];
+	tmp2[30] = product[62];
+	tmp2[31] = product[63];
+	tmp2[8] = tmp2[9] = tmp2[10] = tmp2[11] = 0;
+	carry += vli_lshift(tmp2, tmp2, 1);
+	carry += vli_add(result, result, tmp1);
+	carry += vli_add(result, result, tmp3);
+	carry += vli_add(result, result, tmp2);
+
+	if (carry < 0) {
+		do {
+			carry += vli_add(result, result, mod);
+		} while(carry < 0);
+	} else {
+		while (carry || vli_cmp(mod, result) != 1)
+		{
+			carry -= vli_sub(result, result, mod);
+		}
+	}
+}
+
+/* Computes result = (left * right) % ecc_curve.p. */
+void vli_mod_mult_fast(u8 *result, u8 *left, u8 *right, u8 *mod)
+{
+	u8 product[2 * ECC_NUMWORD];
+
+	vli_mult(product, left, right);
+	vli_mmod_fast(result, product, mod);
+}
+
+/* Computes result = left^2 % ecc_curve.p. */
+void vli_mod_square_fast(u8 *result, u8 *left, u8 *mod)
+{
+	u8 product[2 * ECC_NUMWORD];
+
+	vli_square(product, left);
+	vli_mmod_fast(result, product, mod);
+}
+
+/* Computes result = (left * right) % mod. */
+void vli_mod_mult(u8 *result, u8 *left, u8 *right, u8 *mod)
+{
+	u8 product[2 * ECC_NUMWORD];
+	u8 modMultiple[2 * ECC_NUMWORD];
+	uint digitShift, bitShift;
+	uint productBits;
+	uint modBits = vli_num_bits(mod);
+
+	vli_mult(product, left, right);
+	productBits = vli_num_bits(product + ECC_NUMWORD);
+	if (productBits) {
+		productBits += ECC_NUMWORD * 8;
+	} else {
+		productBits = vli_num_bits(product);
+	}
+
+	if (productBits < modBits) {
+		/* product < mod. */
+		vli_set(result, product);
+		return;
+	}
+
+	/* Shift mod by (leftBits - modBits). This multiplies mod by the largest
+	   power of two possible while still resulting in a number less than left. */
+	vli_clear(modMultiple);
+	vli_clear(modMultiple + ECC_NUMWORD);
+	digitShift = (productBits - modBits) / 8;
+	bitShift = (productBits - modBits) % 8;
+	if (bitShift) {
+		modMultiple[digitShift + ECC_NUMWORD] = vli_lshift(modMultiple + digitShift, mod, bitShift);
+	} else {
+		vli_set(modMultiple + digitShift, mod);
+	}
+
+	/* Subtract all multiples of mod to get the remainder. */
+	vli_clear(result);
+	result[0] = 1; /* Use result as a temp var to store 1 (for subtraction) */
+	while (productBits > ECC_NUMWORD * 8 || vli_cmp(modMultiple, mod) >= 0)
+	{
+		int cmp = vli_cmp(modMultiple + ECC_NUMWORD, product + ECC_NUMWORD);
+		if (cmp < 0 || (cmp == 0 && vli_cmp(modMultiple, product) <= 0)) {
+			if (vli_sub(product, product, modMultiple))
+			{
+				/* borrow */
+				vli_sub(product + ECC_NUMWORD, product + ECC_NUMWORD, result);
+			}
+			vli_sub(product + ECC_NUMWORD, product + ECC_NUMWORD, modMultiple + ECC_NUMWORD);
+		}
+		u8 carry = (modMultiple[ECC_NUMWORD] & 0x01) << 7;
+		vli_rshift1(modMultiple + ECC_NUMWORD);
+		vli_rshift1(modMultiple);
+		modMultiple[ECC_NUMWORD-1] |= carry;
+
+		--productBits;
+	}
+	vli_set(result, product);
+}
+
+#define EVEN(vli) (!(vli[0] & 1))
+/* Computes result = (1 / input) % mod. All VLIs are the same size.
+ * See "From Euclid's GCD to Montgomery Multiplication to the Great Divide"
+ * https://labs.oracle.com/techrep/2001/smli_tr-2001-95.pdf
+ */
+void vli_mod_inv(u8 *result, u8 *input, u8 *mod)
+{
+	u8 a[ECC_NUMWORD], b[ECC_NUMWORD], u[ECC_NUMWORD], v[ECC_NUMWORD];
+	u8 carry;
+	int cmpResult;
+
+	if (vli_is_zero(input)) {
+		vli_clear(result);
+		return;
+	}
+
+	vli_set(a, input);
+	vli_set(b, mod);
+	vli_clear(u);
+	u[0] = 1;
+	vli_clear(v);
+
+	while ((cmpResult = vli_cmp(a, b)) != 0) {
+		carry = 0;
+		if (EVEN(a)) {
+			vli_rshift1(a);
+			if (!EVEN(u)) {
+				carry = vli_add(u, u, mod);
+			}
+			vli_rshift1(u);
+			if (carry) {
+				u[ECC_NUMWORD-1] |= 0x80;
+			}
+		} else if (EVEN(b)) {
+			vli_rshift1(b);
+			if (!EVEN(v)) {
+				carry = vli_add(v, v, mod);
+			}
+			vli_rshift1(v);
+			if (carry) {
+				v[ECC_NUMWORD-1] |= 0x80;
+			}
+		} else if (cmpResult > 0) {
+			vli_sub(a, a, b);
+			vli_rshift1(a);
+			if (vli_cmp(u, v) < 0) {
+				vli_add(u, u, mod);
+			}
+			vli_sub(u, u, v);
+			if (!EVEN(u)) {
+				carry = vli_add(u, u, mod);
+			}
+			vli_rshift1(u);
+			if (carry) {
+				u[ECC_NUMWORD-1] |= 0x80;
+			}
+		} else {
+			vli_sub(b, b, a);
+			vli_rshift1(b);
+			if (vli_cmp(v, u) < 0) {
+				vli_add(v, v, mod);
+			}
+			vli_sub(v, v, u);
+			if (!EVEN(v)) {
+				carry = vli_add(v, v, mod);
+			}
+			vli_rshift1(v);
+			if (carry) {
+				v[ECC_NUMWORD-1] |= 0x80;
+			}
+		}
+	}
+
+	vli_set(result, u);
+}
+
+/* Returns 1 if point is the point at infinity, 0 otherwise. */
+int ecc_point_is_zero(ecc_point *point)
+{
+	return (vli_is_zero(point->x) && vli_is_zero(point->y));
+}
+
+/* Double in place */
+void ecc_point_double_jacobian(u8 *X1, u8 *Y1, u8 *Z1)
+{
+	/* t1 = X, t2 = Y, t3 = Z */
+	u8 t4[ECC_NUMWORD];
+	u8 t5[ECC_NUMWORD];
+
+	if(vli_is_zero(Z1))
+		return;
+
+	vli_mod_square_fast(t4, Y1, ecc_curve.p);   /* t4 = y1^2 */
+	vli_mod_mult_fast(t5, X1, t4, ecc_curve.p); /* t5 = x1*y1^2 = A */
+	vli_mod_square_fast(t4, t4, ecc_curve.p);   /* t4 = y1^4 */
+	vli_mod_mult_fast(Y1, Y1, Z1, ecc_curve.p); /* t2 = y1*z1 = z3 */
+	vli_mod_square_fast(Z1, Z1, ecc_curve.p);   /* t3 = z1^2 */
+
+	vli_mod_add(X1, X1, Z1, ecc_curve.p); /* t1 = x1 + z1^2 */
+	vli_mod_add(Z1, Z1, Z1, ecc_curve.p); /* t3 = 2*z1^2 */
+	vli_mod_sub(Z1, X1, Z1, ecc_curve.p); /* t3 = x1 - z1^2 */
+	vli_mod_mult_fast(X1, X1, Z1, ecc_curve.p);    /* t1 = x1^2 - z1^4 */
+
+	vli_mod_add(Z1, X1, X1, ecc_curve.p); /* t3 = 2*(x1^2 - z1^4) */
+	vli_mod_add(X1, X1, Z1, ecc_curve.p); /* t1 = 3*(x1^2 - z1^4) */
+	if (vli_test_bit(X1, 0)) {
+		u8 carry = vli_add(X1, X1, ecc_curve.p);
+		vli_rshift1(X1);
+		X1[ECC_NUMWORD-1] |= carry << 7;
+	} else {
+		vli_rshift1(X1);
+	}
+
+	/* t1 = 3/2*(x1^2 - z1^4) = B */
+	vli_mod_square_fast(Z1, X1, ecc_curve.p);      /* t3 = B^2 */
+	vli_mod_sub(Z1, Z1, t5, ecc_curve.p); /* t3 = B^2 - A */
+	vli_mod_sub(Z1, Z1, t5, ecc_curve.p); /* t3 = B^2 - 2A = x3 */
+	vli_mod_sub(t5, t5, Z1, ecc_curve.p); /* t5 = A - x3 */
+	vli_mod_mult_fast(X1, X1, t5, ecc_curve.p);    /* t1 = B * (A - x3) */
+	vli_mod_sub(t4, X1, t4, ecc_curve.p); /* t4 = B * (A - x3) - y1^4 = y3 */
+
+	vli_set(X1, Z1);
+	vli_set(Z1, Y1);
+	vli_set(Y1, t4);
+}
+
+/* Modify (x1, y1) => (x1 * z^2, y1 * z^3) */
+void apply_z(u8 *X1, u8 *Y1, u8 *Z)
+{
+	u8 t1[ECC_NUMWORD];
+
+	vli_mod_square_fast(t1, Z, ecc_curve.p);    /* z^2 */
+	vli_mod_mult_fast(X1, X1, t1, ecc_curve.p); /* x1 * z^2 */
+	vli_mod_mult_fast(t1, t1, Z, ecc_curve.p);  /* z^3 */
+	vli_mod_mult_fast(Y1, Y1, t1, ecc_curve.p); /* y1 * z^3 */
+}
+
+/* P = (x1, y1) => 2P, (x2, y2) => P' */
+void XYcZ_initial_double(u8 *X1, u8 *Y1, u8 *X2, u8 *Y2, u8 *initialZ)
+{
+	u8 z[ECC_NUMWORD];
+
+	vli_set(X2, X1);
+	vli_set(Y2, Y1);
+
+	if(initialZ)
+	{
+		vli_set(z, initialZ);
+	}else{
+		vli_clear(z);
+		z[0] = 1;
+	}
+	apply_z(X1, Y1, z);
+
+	ecc_point_double_jacobian(X1, Y1, z);
+
+	apply_z(X2, Y2, z);
+}
+
+/* Input P = (x1, y1, Z), Q = (x2, y2, Z)
+   Output P' = (x1', y1', Z3), P + Q = (x3, y3, Z3)
+   or P => P', Q => P + Q
+   */
+void XYcZ_add(u8 *X1, u8 *Y1, u8 *X2, u8 *Y2)
+{
+	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
+	u8 t5[ECC_NUMWORD];
+
+	vli_mod_sub(t5, X2, X1, ecc_curve.p); /* t5 = x2 - x1 */
+	vli_mod_square_fast(t5, t5, ecc_curve.p);      /* t5 = (x2 - x1)^2 = A */
+	vli_mod_mult_fast(X1, X1, t5, ecc_curve.p);    /* t1 = x1*A = B */
+	vli_mod_mult_fast(X2, X2, t5, ecc_curve.p);    /* t3 = x2*A = C */
+	vli_mod_sub(Y2, Y2, Y1, ecc_curve.p); /* t4 = y2 - y1 */
+	vli_mod_square_fast(t5, Y2, ecc_curve.p);      /* t5 = (y2 - y1)^2 = D */
+
+	vli_mod_sub(t5, t5, X1, ecc_curve.p); /* t5 = D - B */
+	vli_mod_sub(t5, t5, X2, ecc_curve.p); /* t5 = D - B - C = x3 */
+	vli_mod_sub(X2, X2, X1, ecc_curve.p); /* t3 = C - B */
+	vli_mod_mult_fast(Y1, Y1, X2, ecc_curve.p);    /* t2 = y1*(C - B) */
+	vli_mod_sub(X2, X1, t5, ecc_curve.p); /* t3 = B - x3 */
+	vli_mod_mult_fast(Y2, Y2, X2, ecc_curve.p);    /* t4 = (y2 - y1)*(B - x3) */
+	vli_mod_sub(Y2, Y2, Y1, ecc_curve.p); /* t4 = y3 */
+
+	vli_set(X2, t5);
+}
+
+/* Input P = (x1, y1, Z), Q = (x2, y2, Z)
+ * Output P + Q = (x3, y3, Z3), P - Q = (x3', y3', Z3)
+ * or P => P - Q, Q => P + Q
+ */
+void XYcZ_addC(u8 *X1, u8 *Y1, u8 *X2, u8 *Y2)
+{
+	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
+	u8 t5[ECC_NUMWORD];
+	u8 t6[ECC_NUMWORD];
+	u8 t7[ECC_NUMWORD];
+
+	vli_mod_sub(t5, X2, X1, ecc_curve.p); /* t5 = x2 - x1 */
+	vli_mod_square_fast(t5, t5, ecc_curve.p);      /* t5 = (x2 - x1)^2 = A */
+	vli_mod_mult_fast(X1, X1, t5, ecc_curve.p);    /* t1 = x1*A = B */
+	vli_mod_mult_fast(X2, X2, t5, ecc_curve.p);    /* t3 = x2*A = C */
+	vli_mod_add(t5, Y2, Y1, ecc_curve.p); /* t4 = y2 + y1 */
+	vli_mod_sub(Y2, Y2, Y1, ecc_curve.p); /* t4 = y2 - y1 */
+
+	vli_mod_sub(t6, X2, X1, ecc_curve.p); /* t6 = C - B */
+	vli_mod_mult_fast(Y1, Y1, t6, ecc_curve.p);    /* t2 = y1 * (C - B) */
+	vli_mod_add(t6, X1, X2, ecc_curve.p); /* t6 = B + C */
+	vli_mod_square_fast(X2, Y2, ecc_curve.p);      /* t3 = (y2 - y1)^2 */
+	vli_mod_sub(X2, X2, t6, ecc_curve.p); /* t3 = x3 */
+
+	vli_mod_sub(t7, X1, X2, ecc_curve.p); /* t7 = B - x3 */
+	vli_mod_mult_fast(Y2, Y2, t7, ecc_curve.p);    /* t4 = (y2 - y1)*(B - x3) */
+	vli_mod_sub(Y2, Y2, Y1, ecc_curve.p); /* t4 = y3 */
+
+	vli_mod_square_fast(t7, t5, ecc_curve.p);      /* t7 = (y2 + y1)^2 = F */
+	vli_mod_sub(t7, t7, t6, ecc_curve.p); /* t7 = x3' */
+	vli_mod_sub(t6, t7, X1, ecc_curve.p); /* t6 = x3' - B */
+	vli_mod_mult_fast(t6, t6, t5, ecc_curve.p);    /* t6 = (y2 + y1)*(x3' - B) */
+	vli_mod_sub(Y1, t6, Y1, ecc_curve.p); /* t2 = y3' */
+
+	vli_set(X1, t7);
+}
+
+void ecc_point_mult(ecc_point *result, ecc_point *point, u8 *scalar, u8 *initialZ)
+{
+	/* R0 and R1 */
+	u8 Rx[2][ECC_NUMWORD];
+	u8 Ry[2][ECC_NUMWORD];
+	u8 z[ECC_NUMWORD];
+	int i, nb;
+
+	vli_set(Rx[1], point->x);
+	vli_set(Ry[1], point->y);
+
+	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initialZ);
+
+	for (i = vli_num_bits(scalar) - 2; i > 0; --i) {
+		nb = !vli_test_bit(scalar, i);
+		XYcZ_addC(Rx[1-nb], Ry[1-nb], Rx[nb], Ry[nb]);
+		XYcZ_add(Rx[nb], Ry[nb], Rx[1-nb], Ry[1-nb]);
+	}
+
+	nb = !vli_test_bit(scalar, 0);
+	XYcZ_addC(Rx[1-nb], Ry[1-nb], Rx[nb], Ry[nb]);
+
+	/* Find final 1/Z value. */
+	vli_mod_sub(z, Rx[1], Rx[0], ecc_curve.p); /* X1 - X0 */
+	vli_mod_mult_fast(z, z, Ry[1-nb], ecc_curve.p);     /* Yb * (X1 - X0) */
+	vli_mod_mult_fast(z, z, point->x, ecc_curve.p);   /* xP * Yb * (X1 - X0) */
+	vli_mod_inv(z, z, ecc_curve.p);            /* 1 / (xP * Yb * (X1 - X0)) */
+	vli_mod_mult_fast(z, z, point->y, ecc_curve.p);   /* yP / (xP * Yb * (X1 - X0)) */
+	vli_mod_mult_fast(z, z, Rx[1-nb], ecc_curve.p);     /* Xb * yP / (xP * Yb * (X1 - X0)) */
+	/* End 1/Z calculation */
+
+	XYcZ_add(Rx[nb], Ry[nb], Rx[1-nb], Ry[1-nb]);
+
+	apply_z(Rx[0], Ry[0], z);
+
+	vli_set(result->x, Rx[0]);
+	vli_set(result->y, Ry[0]);
+}
+
+static u32 max(u32 a, u32 b)
+{
+        return (a > b ? a : b);
+}
+
+void ecc_point_mult2(ecc_point *result, ecc_point *g, ecc_point *p, u8 *s, u8 *t)
+{
+	u8 tx[ECC_NUMWORD];
+	u8 ty[ECC_NUMWORD];
+	u8 tz[ECC_NUMWORD];
+	u8 z[ECC_NUMWORD];
+	ecc_point sum;
+	u8 *rx;
+	u8 *ry;
+	int i;
+
+	rx = result->x;
+	ry = result->y;
+
+	/* Calculate sum = G + Q. */
+	vli_set(sum.x, p->x);
+	vli_set(sum.y, p->y);
+	vli_set(tx, g->x);
+	vli_set(ty, g->y);
+
+	vli_mod_sub(z, sum.x, tx, ecc_curve.p); /* Z = x2 - x1 */
+	XYcZ_add(tx, ty, sum.x, sum.y);
+	vli_mod_inv(z, z, ecc_curve.p); /* Z = 1/Z */
+	apply_z(sum.x, sum.y, z);
+
+	/* Use Shamir's trick to calculate u1*G + u2*Q */
+	ecc_point *points[4] = {NULL, g, p, &sum};
+	u32 numBits = max(vli_num_bits(s), vli_num_bits(t));
+
+	ecc_point *point = points[(!!vli_test_bit(s, numBits-1)) | ((!!vli_test_bit(t, numBits-1)) << 1)];
+	vli_set(rx, point->x);
+	vli_set(ry, point->y);
+	vli_clear(z);
+	z[0] = 1;
+
+	for (i = numBits - 2; i >= 0; --i) {
+		ecc_point_double_jacobian(rx, ry, z);
+
+		int index = (!!vli_test_bit(s, i)) | ((!!vli_test_bit(t, i)) << 1);
+		ecc_point *point = points[index];
+		if(point) {
+			vli_set(tx, point->x);
+			vli_set(ty, point->y);
+			apply_z(tx, ty, z);
+			vli_mod_sub(tz, rx, tx, ecc_curve.p); /* Z = x2 - x1 */
+			XYcZ_add(tx, ty, rx, ry);
+			vli_mod_mult_fast(z, z, tz, ecc_curve.p);
+		}
+	}
+
+	vli_mod_inv(z, z, ecc_curve.p); /* Z = 1/Z */
+	apply_z(rx, ry, z);
+}
+
+void ecc_point_add(ecc_point *result, ecc_point *left, ecc_point *right)
+{
+	u8 x1[ECC_NUMWORD];
+	u8 y1[ECC_NUMWORD];
+	u8 x2[ECC_NUMWORD];
+	u8 y2[ECC_NUMWORD];
+	u8 z[ECC_NUMWORD];
+
+	vli_set(x1, left->x);
+	vli_set(y1, left->y);
+	vli_set(x2, right->x);
+	vli_set(y2, right->y);
+
+	vli_mod_sub(z, x2, x1, ecc_curve.p); /* Z = x2 - x1 */
+
+	XYcZ_add(x1, y1, x2, y2);
+	vli_mod_inv(z, z, ecc_curve.p); /* Z = 1/Z */
+	apply_z(x2,y2, z);
+
+	vli_set(result->x, x2);
+	vli_set(result->y, y2);
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/generic.mk b/src/libstrongswan/plugins/gmalg/gmalg/generic.mk
new file mode 100644
index 000000000..1c3f952aa
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/generic.mk
@@ -0,0 +1,10 @@
+
+IDIR            += ./include
+IDIR            += ./private_include
+
+CFLAGS          := $(addprefix -I, $(IDIR))
+CFLAGS          += $(addprefix -L, $(LDIR))
+CFLAGS          += $(addprefix -D, $(DEFS))
+CFLAGS          += -shared -fPIC -Werror -O3
+
+export IDIR LDIR DEFS
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/gmalg.c b/src/libstrongswan/plugins/gmalg/gmalg/gmalg.c
new file mode 100644
index 000000000..4b4d57bcd
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/gmalg.c
@@ -0,0 +1,438 @@
+/*
+ * Cryptographic application identifier criterion specification
+ * Code URL     : https://github.com/zhangke5959
+ * Maintainer   : Zhang Ke <zhangke5959@126.com>
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+
+#include "debug.h"
+#include "random.h"
+#include "sm2.h"
+#include "sm3.h"
+#include "sm4.h"
+#include "gmalg.h"
+
+#define D2I_PUB(pub) ((struct ecc_point *)pub->x)
+#define D2I_PRI(pri) ((unsigned char *)pri->K)
+
+typedef struct gmalg_ctx_st {
+	sm3_ctx sm3_ctx[1];
+	sm4_ctx sm4_ctx[1];
+} gmalg_ctx;
+
+int GMALG_LibTest(void)
+{
+	int rc = 0;
+	printf("GMAL library test ok. \n");
+	return rc;
+}
+
+int GMALG_OpenDevice(
+	void **phDeviceHandle)
+{
+	int rc = 0;
+	void *p;
+
+	p = malloc(sizeof(gmalg_ctx));
+	if ( p == NULL)
+		return -1;
+
+	*phDeviceHandle = p;
+
+	return rc;
+}
+
+int GMALG_CloseDevice(
+	void *hDeviceHandle)
+{
+	int rc = 0;
+
+	if(hDeviceHandle)
+		free(hDeviceHandle);
+
+	return rc;
+}
+
+int GMALG_GenerateRandom(
+	void *hDeviceHandle,
+	unsigned int uiLength,
+	unsigned char *pucRandom)
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	int rc = 0;
+
+	rc = vli_get_random(pucRandom, uiLength);
+
+	return rc;
+}
+
+int GMALG_pointMul_ECC (
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucG,
+	ECCrefPrivateKey *pucK,
+	ECCrefPublicKey *pucP)
+{
+	int rc = 0;
+
+	sm2_point_mult(D2I_PUB(pucG), D2I_PRI(pucK), D2I_PUB(pucP)); /* U=[x2_]RB */
+
+	return rc;
+}
+
+int GMALG_GeneratePublicKey_ECC (
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucPrivateKey,
+	ECCrefPublicKey *pucPublicKey)
+{
+	ecc_point pubKey[1];
+	int rc = 0;
+
+	rc = sm2_make_pubkey(D2I_PRI(pucPrivateKey), pubKey);
+
+	pucPublicKey->bits = htonl(0x100);
+	memcpy(pucPublicKey->x, pubKey->x, ECC_NUMWORD);
+	memcpy(pucPublicKey->y, pubKey->y, ECC_NUMWORD);
+
+	return rc;
+}
+
+int GMALG_GenerateKeyPair_ECC(
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucPublicKey,
+	ECCrefPrivateKey *pucPrivateKey)
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	u8 priKey[ECC_NUMWORD];
+	ecc_point pubKey[1];
+	int rc = 0;
+
+	rc = sm2_make_prikey(priKey);
+	rc = sm2_make_pubkey(priKey, pubKey);
+
+	pucPrivateKey->bits = htonl(0x100);
+	memcpy( pucPrivateKey->K, priKey, ECC_NUMWORD);
+	pucPublicKey->bits = htonl(0x100);
+	memcpy(pucPublicKey->x, pubKey->x, ECC_NUMWORD);
+	memcpy(pucPublicKey->y, pubKey->y, ECC_NUMWORD);
+
+	return rc;
+}
+
+int GMALG_ExternalSign_ECC(
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucPrivateKey,
+	unsigned char *pucData,
+	unsigned int uiDataLength,
+	ECCSignature *pucSignature)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	int rc = 0;
+
+	rc = sm2_sign(pucSignature->r, pucSignature->s, pucPrivateKey->K, pucData);
+
+	return rc;
+}
+
+int GMALG_ExternalVerify_ECC(
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucPublicKey,
+	unsigned char *pucDataInput,
+	unsigned int uiInputLength,
+	ECCSignature *pucSignature)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	int rc = 0;
+
+	rc = sm2_verify(D2I_PUB(pucPublicKey), pucDataInput, pucSignature->r, pucSignature->s);
+
+	return rc;
+}
+
+int GMALG_ExternalEncrytp_ECC(
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucPublicKey,
+	unsigned char *pucData,
+	unsigned int uiDataLength,
+	ECCCipher *pucEncData)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	int rc = 0;
+
+	rc = sm2_encrypt(D2I_PUB(pucPublicKey), pucData, uiDataLength,
+			pucEncData->C, &pucEncData->L);
+
+	memset(pucEncData->M, 0, ECC_NUMWORD);
+	memcpy(pucEncData->x, pucPublicKey->x,ECC_NUMWORD);
+	memcpy(pucEncData->y, pucPublicKey->y, ECC_NUMWORD);
+
+	return rc;
+}
+
+int GMALG_ExternalDecrypt_ECC(
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucPrivateKey,
+	ECCCipher *pucEncData,
+	unsigned char *pucData,
+	unsigned int *puiDataLength)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	unsigned int dataLen = 0;
+	int rc = 0;
+
+	rc = sm2_decrypt(pucPrivateKey->K, pucEncData->C, pucEncData->L,
+			pucData, &dataLen);
+
+	return rc;
+}
+
+int GMALG_Encrypt(
+	void *hDeviceHandle,
+	void *pucKey,
+	unsigned int uiAlgID,
+	unsigned char *pucIV,
+	unsigned char *pucData,
+	unsigned int uiDataLength,
+	unsigned char *pucEncData,
+	unsigned int *puiEncDataLength)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	int rc = 0;
+
+	switch( uiAlgID){
+	case GMALG_SM1_ECB:{
+		sm4_ecb_encrypt(ctx->sm4_ctx, pucKey, pucData, uiDataLength, pucEncData);
+		if(puiEncDataLength)
+			*puiEncDataLength = uiDataLength;
+	}break;
+	case GMALG_SM1_CBC:{
+		sm4_cbc_encrypt(ctx->sm4_ctx, pucKey, pucIV, pucData, uiDataLength, pucEncData);
+		if(puiEncDataLength)
+			*puiEncDataLength = uiDataLength;
+	}break;
+	case GMALG_SM4_ECB:{
+		sm4_ecb_encrypt(ctx->sm4_ctx, pucKey, pucData, uiDataLength, pucEncData);
+		if(puiEncDataLength)
+			*puiEncDataLength = uiDataLength;
+	}break;
+	case GMALG_SM4_CBC:{
+		sm4_cbc_encrypt(ctx->sm4_ctx, pucKey, pucIV, pucData, uiDataLength, pucEncData);
+		if(puiEncDataLength)
+			*puiEncDataLength = uiDataLength;
+	}break;
+	default:{ rc = -1;}
+	}
+
+	return rc;
+}
+
+int GMALG_Decrypt (
+	void *hDeviceHandle,
+	void *pucKey,
+	unsigned int uiAlgID,
+	unsigned char *pucIV,
+	unsigned char *pucEncData,
+	unsigned int uiEncDataLength,
+	unsigned char *pucData,
+	unsigned int *puiDataLength)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	int rc = 0;
+
+	switch( uiAlgID){
+	case GMALG_SM1_ECB:{
+		sm4_ecb_decrypt(ctx->sm4_ctx, pucKey, pucEncData, uiEncDataLength, pucData);
+		if(puiDataLength)
+			*puiDataLength = uiEncDataLength;
+	}break;
+	case GMALG_SM1_CBC:{
+		sm4_cbc_decrypt(ctx->sm4_ctx, pucKey, pucIV, pucEncData, uiEncDataLength, pucData);
+		if(puiDataLength)
+			*puiDataLength = uiEncDataLength;
+	}break;
+	case GMALG_SM4_ECB:{
+		sm4_ecb_decrypt(ctx->sm4_ctx, pucKey, pucEncData, uiEncDataLength, pucData);
+		if(puiDataLength)
+			*puiDataLength = uiEncDataLength;
+	}break;
+	case GMALG_SM4_CBC:{
+		sm4_cbc_decrypt(ctx->sm4_ctx, pucKey, pucIV, pucEncData, uiEncDataLength, pucData);
+		if(puiDataLength)
+			*puiDataLength = uiEncDataLength;
+	}break;
+	default:{ rc = -1;}
+	}
+
+	return rc;
+}
+
+int GMALG_HashInit (
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucPublicKey,
+	unsigned char *pucID,
+	unsigned int uiIDLength)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	u8 Z[ECC_NUMWORD];
+	int rc = 0;
+
+	rc = sm3_init(ctx->sm3_ctx);
+
+	if (uiIDLength) {
+		sm3_z(pucID, uiIDLength, (ecc_point *)pucPublicKey->x, Z);
+		sm3_update(ctx->sm3_ctx, Z, ECC_NUMWORD);
+	}
+
+	return rc;
+}
+
+int GMALG_HashUpdate (
+	void *hDeviceHandle,
+	unsigned char *pucData,
+	unsigned int uiDataLength)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	int rc = 0;
+
+	rc = sm3_update(ctx->sm3_ctx, pucData, uiDataLength);
+
+	return rc;
+}
+
+int GMALG_HashFinal (
+	void *hDeviceHandle,
+	unsigned char *pucHash,
+	unsigned int *puiHashLength)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	int rc = 0;
+
+	rc = sm3_finish(ctx->sm3_ctx, pucHash);
+	if(puiHashLength)
+		*puiHashLength =  32;
+
+	return rc;
+}
+
+typedef struct agreement_t {
+	u8 ZA[ECC_NUMWORD];
+	u8 priKey[ECC_NUMWORD];
+	u8 tempPriKey[ECC_NUMWORD];
+	ecc_point pubKey[1];
+	ecc_point tempPubKey[1];
+	u32 keyLen;
+} agreement;
+
+int GMALG_GenerateAgreementDataWithECC (
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucSponsePrivateKey,
+	ECCrefPublicKey *pucSponsorPublicKey,
+	unsigned int uiKey,
+	unsigned char *pucSponsorID,
+	unsigned int uiSponsorIDLength,
+	ECCrefPublicKey *pucSponsorTmpPublicKey,
+	void **phAgreementHandle)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	agreement *agree = (agreement *)malloc(sizeof(agreement));
+	int rc = 0;
+
+	sm2_make_keypair(agree->tempPriKey, agree->tempPubKey);
+	sm3_z(pucSponsorID, uiSponsorIDLength, D2I_PUB(pucSponsorPublicKey), agree->ZA);
+
+	agree->keyLen = uiKey;
+	memcpy(agree->pubKey->x, pucSponsorPublicKey->x, ECC_NUMWORD);
+	memcpy(agree->pubKey->y, pucSponsorPublicKey->y, ECC_NUMWORD);
+	memcpy(agree->priKey, pucSponsePrivateKey->K, ECC_NUMWORD);
+
+	pucSponsorTmpPublicKey->bits = htonl(0x100);
+	memcpy(pucSponsorTmpPublicKey->x, agree->tempPubKey->x, ECC_NUMWORD);
+	memcpy(pucSponsorTmpPublicKey->y, agree->tempPubKey->y, ECC_NUMWORD);
+
+	*phAgreementHandle = agree;
+
+	return rc;
+}
+
+int GMALG_GenerateKeyWithECC (
+	void *hDeviceHandle,
+	unsigned char *pucResponseID,
+	unsigned int uiResponseIDLength,
+	ECCrefPublicKey *pucResponsePublicKey,
+	ECCrefPublicKey *pucResponseTmpPublicKey,
+	void *hAgreementHandle,
+	void *phKey)
+
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	agreement *agree = (agreement *)hAgreementHandle;
+	ecc_point tempPubKey[1];
+	u8 ZB[ECC_NUMWORD];
+	int rc = 0;
+
+	sm3_z(pucResponseID, uiResponseIDLength, agree->pubKey, ZB);
+
+	sm2_shared_point(agree->priKey, agree->tempPriKey, agree->tempPubKey,
+			D2I_PUB(pucResponsePublicKey), D2I_PUB(pucResponseTmpPublicKey),
+			tempPubKey);
+
+	sm2_shared_key(tempPubKey, agree->ZA, ZB, agree->keyLen, phKey);
+
+	free(agree);
+
+	return rc;
+}
+
+int GMALG_GenerateAgreementDataAndKeyWithECC(
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucResponsePrivateKey,
+	ECCrefPublicKey *pucResponsePublicKey,
+	unsigned int uiKey,
+	unsigned char *pucResponseID,
+	unsigned int uiResponseIDLength,
+	unsigned char *pucSponsorID,
+	unsigned int uiSponsorIDLength,
+	ECCrefPublicKey *pucSponsorPublicKey,
+	ECCrefPublicKey *pucSponsorTmpPublicKey,
+	ECCrefPublicKey *pucResponseTmpPublicKey,
+	void *phKey)
+{
+	gmalg_ctx *ctx = (gmalg_ctx *)hDeviceHandle;
+	u8 tempPriKey[ECC_NUMWORD];
+	ecc_point tempPubKey[1];
+	u8 ZA[ECC_NUMWORD];
+	u8 ZB[ECC_NUMWORD];
+	int rc = 0;
+
+	sm2_make_keypair(tempPriKey, tempPubKey);
+
+	sm2_shared_point(D2I_PRI(pucResponsePrivateKey), tempPriKey, tempPubKey,
+			D2I_PUB(pucSponsorPublicKey), D2I_PUB(pucSponsorTmpPublicKey),
+			tempPubKey);
+
+	sm3_z(pucSponsorID, uiSponsorIDLength, D2I_PUB(pucSponsorPublicKey), ZA);
+	sm3_z(pucResponseID, uiResponseIDLength, D2I_PUB(pucResponsePublicKey), ZB);
+
+	sm2_shared_key(tempPubKey, ZA, ZB, uiKey, phKey);
+
+	pucResponseTmpPublicKey->bits = htonl(0x100);
+	memcpy(pucResponseTmpPublicKey->x, tempPubKey->x, ECC_NUMWORD);
+	memcpy(pucResponseTmpPublicKey->y, tempPubKey->y, ECC_NUMWORD);
+
+	return rc;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/include/gmalg.h b/src/libstrongswan/plugins/gmalg/gmalg/include/gmalg.h
new file mode 100644
index 000000000..a8a59def1
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/include/gmalg.h
@@ -0,0 +1,390 @@
+/*
+ * Cryptographic application identifier criterion specification
+ * Code URL     : https://github.com/zhangke5959
+ * Maintainer   : Zhang Ke <zhangke5959@126.com>
+ */
+
+#ifndef _GMALG_H_
+#define _GMALG_H_
+
+#define GMALG_SM1_ECB 0x00000101 /*SM1 算法 ECB 加密模式*/
+#define GMALG_SM1_CBC 0x00000102 /*SM1 算法 CBC 加密模式*/
+#define GMALG_SM1_CFB 0x00000104 /*SM1 算法 CFB 加密模式*/
+#define GMALG_SM1_OFB 0x00000108 /*SM1 算法 OFB 加密模式*/
+#define GMALG_SM1_MAC 0x00000110 /*SM1 算法 MAC 加密模式*/
+
+#define GMALG_SM4_ECB 0x00000401 /*SM4 算法 ECB 加密模式*/
+#define GMALG_SM4_CBC 0x00000402 /*SM4 算法 CBC 加密模式*/
+#define GMALG_SM4_CFB 0x00000404 /*SM4 算法 CFB 加密模式*/
+#define GMALG_SM4_OFB 0x00000408 /*SM4 算法 OFB 加密模式*/
+#define GMALG_SM4_MAC 0x00000410 /*SM4 算法 MAC 加密模式*/
+
+/**< ECC definition groups */
+#define ECCref_MAX_BITS		256
+#define ECCref_MAX_LEN		((ECCref_MAX_BITS+7) / 8)
+
+/***********公钥数据结构定义**********/
+/* 字段名称  数据长度       含义     */
+/*************************************/
+/*   bits      4        模长         */
+/*   x         32       公钥 x 坐标  */
+/*   y         32       公钥 y 坐标  */
+/*************************************/
+typedef struct ECCrefPublicKey_st {
+	unsigned int    bits;
+	unsigned char   x[ECCref_MAX_LEN];
+	unsigned char   y[ECCref_MAX_LEN];
+} ECCrefPublicKey;
+
+/***********私钥数据结构定义******/
+/* 字段名称  数据长度    含义    */
+/*********************************/
+/*   bits      4        模长     */
+/*   bits      4        模长     */
+/*   D         32       私钥     */
+/*********************************/
+typedef struct ECCrefPrivateKey_st {
+	unsigned int    bits;
+	unsigned char   K[ECCref_MAX_LEN];
+} ECCrefPrivateKey;
+
+/***********加密数据结构定义******************************/
+/* 字段名称  数据长度            含义                    */
+/*********************************************************/
+/*   x         32       与 y 组成椭圆曲线上的点（x，y）  */
+/*   y         32       与 x 组成椭圆曲线上的点（x，y）  */
+/*   M         32       预留，用于支持带MAC输出的ECC算法 */
+/*   L         4        加密数据长度                     */
+/*   C         32       加密数据                         */
+/*********************************************************/
+typedef struct ECCCipher_st {
+	unsigned char   x[ECCref_MAX_LEN];
+	unsigned char   y[ECCref_MAX_LEN];
+	unsigned char   M[ECCref_MAX_LEN];
+	unsigned int    L;
+	unsigned char   C[ECCref_MAX_LEN];
+} ECCCipher;
+
+/***********签名数据结构定义************/
+/* 字段名称  数据长度        含义      */
+/***************************************/
+/*   r         32       签名的 r 部分  */
+/*   s         32       签名的 s 部分  */
+/***************************************/
+typedef struct ECCSignature_st {
+	unsigned char   r[ECCref_MAX_LEN];
+	unsigned char   s[ECCref_MAX_LEN];
+} ECCSignature;
+
+/*
+ * 描述： 库测试函数
+ * 参数： 无参数
+ * 返回值： 0 成功
+ *          非 0 失败，返回错误代码
+ */
+extern int GMALG_LibTest (void);
+
+/*
+ * 描述： 打开密码设备
+ * 参数： phDeviceHandle[out] 返回设备句柄
+ * 返回值： 0 成功
+ *          非 0 失败，返回错误代码
+ * 备注： phDeviceHandle 由函数初始化并填写内容
+ */
+extern int GMALG_OpenDevice (void **phDeviceHandle);
+
+/*
+ *描述： 关闭密码设备，并释放相关资源
+ *参数： hDeviceHandle[in] 已打开的设备句柄
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_CloseDevice (void *hDeviceHandle);
+
+/*
+ *描述： 获取指定长度的随机数
+ *参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *       uiLength[in]       欲获取的随机数长度
+ *       pucRandom[out]     缓冲区指针，用于存放获取的随机数
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_GenerateRandom (
+	void *hDeviceHandle,
+	unsigned int uiLength,
+	unsigned char *pucRandom);
+
+/*
+ *描述： 请求密码设备 ECC 倍点运算
+ *参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *       pucG[in]           ECC 基点
+ *       pucK[in]           ECC 倍数
+ *       pucP[out]          ECC 倍点后的值
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_pointMul_ECC (
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucG,
+	ECCrefPrivateKey *pucK,
+	ECCrefPublicKey *pucP);
+
+/*
+ *描述： 请求密码设备 通过私钥获得公钥
+ *参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *       pucPrivateKey[in] ECC 私钥结构
+ *       pucPublicKey[out]  ECC 公钥结构
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_GeneratePublicKey_ECC (
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucPrivateKey,
+	ECCrefPublicKey *pucPublicKey);
+
+/*
+ *描述： 请求密码设备产生 ECC 密钥对
+ *参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *       pucPublicKey[out]  ECC 公钥结构
+ *       pucPrivateKey[out] ECC 私钥结构
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_GenerateKeyPair_ECC (
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucPublicKey,
+	ECCrefPrivateKey *pucPrivateKey);
+
+/*
+ * 描述： 使用外部 ECC 私钥对数据进行签名运算
+ * 参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *        pucPrivateKey[in]  外部 ECC 私钥结构
+ *        pucData[in]        缓冲区指针，用于存放外部输入的数据
+ *        uiDataLength[in]   输入的数据长度
+ *        pucSignature[out]  缓冲区指针，用于存放输出的签名值数据
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_ExternalSign_ECC (
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucPrivateKey,
+	unsigned char *pucData,
+	unsigned int uiDataLength,
+	ECCSignature *pucSignature);
+
+/*
+ * 描述： 使用外部 ECC 公钥对 ECC 签名值进行验证运算
+ * 参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *        pucPublicKey[in]   外部 ECC 公钥结构
+ *        pucData[in]        缓冲区指针，用于存放外部输入的数据
+ *        uiDataLength[in]   输入的数据长度
+ *        pucSignature[in]   缓冲区指针，用于存放输入的签名值数据
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_ExternalVerify_ECC (
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucPublicKey,
+	unsigned char *pucDataInput,
+	unsigned int uiInputLength,
+	ECCSignature *pucSignature);
+
+/*
+ * 描述： 使用外部 ECC 公钥对数据进行加密运算
+ * 参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *        pucPublicKey[in]   外部 ECC 公钥结构
+ *        pucData[in]        缓冲区指针，用于存放外部输入的数据
+ *        uiDataLength[in]   输入的数据长度
+ *        pucEncData[out]    缓冲区指针，用于存放输出的数据密文
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_ExternalEncrytp_ECC (
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucPublicKey,
+	unsigned char *pucData,
+	unsigned int uiDataLength,
+	ECCCipher *pucEncData);
+
+/*
+ * 描述： 使用外部 ECC 私钥进行解密运算
+ * 参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *        uiAlgID[in]        算法标识，指定使用的 ECC 算法
+ *        pucPrivateKey[in]  外部 ECC 私钥结构
+ *        pucEncData[in]     缓冲区指针，用于存放输入的数据密文
+ *        pucData[out]       缓冲区指针，用于存放输出的数据明文
+ *        puiDataLength[out] 输出的数据明文长度
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_ExternalDecrypt_ECC (
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucPrivateKey,
+	ECCCipher *pucEncData,
+	unsigned char *pucData,
+	unsigned int *puiDataLength);
+
+/*
+ * 描述： 使用指定的密钥和 IV 对数据进行对称加密运算
+ * 参数： hDeviceHandle[in]     与设备建立的会话句柄
+ *        hpucKey[in]           指定的密钥句柄
+ *        uiAlgID[in]           算法标识，指定对称加密算法
+ *        pucIV[in|out]         缓冲区指针，用于存放输入和返回的 IV 数据
+ *        pucData[in]           缓冲区指针，用于存放输入的数据明文
+ *        uiDataLength[in]      输入的数据明文长度
+ *        pucEncData[out]       缓冲区指针，用于存放输出的数据密文
+ *        puiEncDataLength[out] 输出的数据密文长度
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_Encrypt (
+	void *hDeviceHandle,
+	void *pucKey,
+	unsigned int uiAlgID,
+	unsigned char *pucIV,
+	unsigned char *pucData,
+	unsigned int uiDataLength,
+	unsigned char *pucEncData,
+	unsigned int *puiEncDataLength);
+
+/*
+ * 描述： 使用指定的密钥句柄和 IV 对数据进行对称解密运算
+ * 参数： hDeviceHandle[in]   与设备建立的会话句柄
+ *        hpucKey[in]         指定的密钥句柄
+ *        uiAlgID[in]         算法标识，指定对称加密算法
+ *        pucIV[in|out]       缓冲区指针，用于存放输入和返回的 IV 数据
+ *        pucEncData[in]      缓冲区指针，用于存放输入的数据密文
+ *        uiEncDataLength[in] 输入的数据密文长度
+ *        pucData[out]        缓冲区指针，用于存放输出的数据明文
+ *        puiDataLength[out]  输出的数据明文长度
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_Decrypt (
+	void *hDeviceHandle,
+	void *pucKey,
+	unsigned int uiAlgID,
+	unsigned char *pucIV,
+	unsigned char *pucEncData,
+	unsigned int uiEncDataLength,
+	unsigned char *pucData,
+	unsigned int *puiDataLength);
+
+/*
+ * 描述： 三步式数据杂凑运算第一步。
+ * 参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *        pucPublicKey[in]   签名者的ECC公钥，产生用于ECC签名的杂凑值时有效
+ *        pucID[in]          签名者的ID值， 产生用于ECC签名的杂凑值时有效
+ *        uiIDLength[in]     签名者的ID长度
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_HashInit (
+	void *hDeviceHandle,
+	ECCrefPublicKey *pucPublicKey,
+	unsigned char *pucID,
+	unsigned int uiIDLength);
+
+/*
+ * 描述： 三步式数据杂凑运算第二步，对输入的明文进行杂凑运算
+ * 参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *        pucData[in]        缓冲区指针，用于存放输入的数据明文
+ *        uiDataLength[in]   输入的数据明文长度
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_HashUpdate (
+	void *hDeviceHandle,
+	unsigned char *pucData,
+	unsigned int uiDataLength);
+
+/*
+ * 描述： 三步式数据杂凑运算第三步，杂凑运算结束返回杂凑数据并清除中间数据
+ * 参数： hDeviceHandle[in]  与设备建立的会话句柄
+ *        pucHash[out]       缓冲区指针，用于存放输出的杂凑数据
+ *        puiHashLength[out] 返回的杂凑数据长度
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_HashFinal (
+	void *hDeviceHandle,
+	unsigned char *pucHash,
+	unsigned int *puiHashLength);
+
+/*
+ * 描述： 使用 ECC 密钥协商算法，为计算会话密钥而产生协商参数，同时返回自己 ECC
+ *           公钥、临时 ECC 密钥对的公钥及协商柄。
+ * 参数： hDeviceHandle[in]        与设备建立的会话句柄
+ *        pucSponsePrivateKey[in]  密码设备加密私钥，该私钥用于参与密钥协商
+ *        pucSelfPublicKey[in]     密码设备加密公钥，该私钥用于参与密钥协商
+ *        uiKey[in]            要求协商的密钥字节长度
+ *        pucSponsorID[in]         参与密钥协商的发起方 ID 值
+ *        uiSponsorIDLength[in]    发起方 ID 长度
+ *        pucSelfTmpPublicKey[out] 返回的发起方临时 ECC 公钥结构
+ *        phAgreementHandle[out]   返回的协商句柄，用于计算协商密钥
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_GenerateAgreementDataWithECC (
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucSponsePrivateKey,
+	ECCrefPublicKey *pucSponsorPublicKey,
+	unsigned int uiKey,
+	unsigned char *pucSponsorID,
+	unsigned int uiSponsorIDLength,
+	ECCrefPublicKey *pucSponsorTmpPublicKey,
+	void **phAgreementHandle);
+
+/*
+ * 描述： 使用ECC密钥协商算法，使用自身协商句柄和响应方的协商参数计算会话密钥，同
+ *           时返回会话密钥。
+ * 参数： hDeviceHandle[in]           与设备建立的会话句柄
+ *        pucResponseID[in]           外部输入的响应方 ID 值
+ *        uiResponseIDLength[in]      外部输入的响应方 ID 长度
+ *        pucResponsePublicKey[in]    外部输入的响应方 ECC 公钥结构
+ *        pucResponseTmpPublicKey[in] 外部输入的响应方临时 ECC 公钥结构
+ *        hAgreementHandle[in]        协商句柄，用于计算协商密钥
+ *        phKey[out]                  返回的密钥数据
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_GenerateKeyWithECC (
+	void *hDeviceHandle,
+	unsigned char *pucResponseID,
+	unsigned int uiResponseIDLength,
+	ECCrefPublicKey *pucResponsePublicKey,
+	ECCrefPublicKey *pucResponseTmpPublicKey,
+	void *hAgreementHandle,
+	void *phKey);
+
+/*
+ * 描述： 使用ECC密钥协商算法，产生协商参数并计算会话密钥，同时返回产生的协商参数和密钥。
+ * 参数： hDeviceHandle[in]            与设备建立的会话句柄
+ *        pucResponsePrivateKey[in]    密码设备加密私钥，该私钥用于参与密钥协商
+ *        pucResponsePublicKey[in]     密码设备加密公钥，该私钥用于参与密钥协商
+ *        uiKey[in]                    协商后要求输出的密钥字节长度
+ *        pucResponseID[in]            响应方 ID 值
+ *        uiResponseIDLength[in]       响应方 ID 长度
+ *        pucSponsorID[in]             发起方 ID 值
+ *        uiSponsorIDLength[in]        发起方 ID 长度
+ *        pucSponsorPublicKey[in]      外部输入的发起方 ECC 公钥结构
+ *        pucSponsorTmpPublicKey[in]   外部输入的发起方临时 ECC 公钥结构
+ *        pucResponseTmpPublicKey[out] 返回的响应方临时 ECC 公钥结构
+ *        phKey[out]                   返回的密钥数据
+ *返回值： 0 成功
+ *         非 0 失败，返回错误代码
+ */
+extern int GMALG_GenerateAgreementDataAndKeyWithECC(
+	void *hDeviceHandle,
+	ECCrefPrivateKey *pucResponsePrivateKey,
+	ECCrefPublicKey *pucResponsePublicKey,
+	unsigned int uiKey,
+	unsigned char *pucResponseID,
+	unsigned int uiResponseIDLength,
+	unsigned char *pucSponsorID,
+	unsigned int uiSponsorIDLength,
+	ECCrefPublicKey *pucSponsorPublicKey,
+	ECCrefPublicKey *pucSponsorTmpPublicKey,
+	ECCrefPublicKey *pucResponseTmpPublicKey,
+	void *phKey);
+#endif
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/private_include/debug.h b/src/libstrongswan/plugins/gmalg/gmalg/private_include/debug.h
new file mode 100644
index 000000000..e03a8652e
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/private_include/debug.h
@@ -0,0 +1,10 @@
+#ifndef __DEBUG_H_
+#define __DEBUG_H_
+
+#define DEBUG 0
+#define ALG_DEBUG 0
+
+void printHex(unsigned char *name, unsigned char *c, int n);
+void speed_test( char *name, int len);
+
+#endif
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/private_include/ecc.h b/src/libstrongswan/plugins/gmalg/gmalg/private_include/ecc.h
new file mode 100644
index 000000000..f11132cba
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/private_include/ecc.h
@@ -0,0 +1,125 @@
+#ifndef _ECC_H_
+#define _ECC_H_
+
+#include "typedef.h"
+
+#define ECC_WORDSIZE 8
+#define ECC_NUMBITS 256
+#define ECC_NUMWORD (ECC_NUMBITS/ECC_WORDSIZE) //32
+
+#define SWAP(a,b) { u32 t = a; a = b; b = t;}
+
+#define digit2str16(x, y)   {                               \
+	        (y)[0] = (u8)((x >> 8 ) & 0x000000FF);      \
+	        (y)[1] = (u8)((x >> 0 ) & 0x000000FF);      \
+}
+
+#define str2digit16(y, x)    {                                  \
+	        x = ((((u16)(y)[0]) & 0x000000FF) << 8)  |  \
+	            ((((u16)(y)[1]) & 0x000000FF) << 0 );   \
+}
+
+#define digit2str32(x, y)   {                               \
+	        (y)[0] = (u8)((x >> 24) & 0x000000FF);      \
+	        (y)[1] = (u8)((x >> 16) & 0x000000FF);      \
+	        (y)[2] = (u8)((x >> 8 ) & 0x000000FF);      \
+	        (y)[3] = (u8)((x >> 0 ) & 0x000000FF);      \
+}
+
+#define str2digit32(y, x)    {                                   \
+	        x = ((((u32)(y)[0]) & 0x000000FF) << 24)  |  \
+	            ((((u32)(y)[1]) & 0x000000FF) << 16)  |  \
+	            ((((u32)(y)[2]) & 0x000000FF) << 8 )  |  \
+	            ((((u32)(y)[3]) & 0x000000FF) << 0 );    \
+}
+
+typedef struct ecc_point
+{
+    u8 x[ECC_NUMWORD];
+    u8 y[ECC_NUMWORD];
+} ecc_point;
+
+struct ecc_curve {
+	struct ecc_point g;
+	u8 p[ECC_NUMWORD];
+	u8 n[ECC_NUMWORD];
+	u8 h[ECC_NUMWORD];
+	u8 a[ECC_NUMWORD];
+	u8 b[ECC_NUMWORD];
+};
+
+void ecc_point_add(ecc_point *result, ecc_point *x, ecc_point *y);
+void ecc_point_mult(ecc_point *result, ecc_point *point, u8 *scalar, u8 *initialZ);
+void ecc_point_mult2(ecc_point *result, ecc_point *g, ecc_point *p, u8 *s, u8 *t);
+int ecc_point_is_zero(ecc_point *point);
+
+typedef struct {
+	u64 m_low;
+	u64 m_high;
+} u128;
+
+void vli_clear(u8 *vli);
+
+/* Returns true if vli == 0, false otherwise. */
+int vli_is_zero(u8 *vli);
+
+/* Returns nonzero if bit bit of vli is set. */
+u8 vli_test_bit(u8 *vli, uint bit);
+
+/* Counts the number of 8-bit "digits" in vli. */
+u32 vli_num_digits(u8 *vli);
+
+/* Counts the number of bits required for vli. */
+u32 vli_num_bits(u8 *vli);
+/* Sets dest = src. */
+
+void vli_set(u8 *dest, u8 *src);
+
+/* Returns sign of left - right. */
+int vli_cmp(u8 *left, u8 *right);
+
+/* Computes result = in << c, returning carry. Can modify in place
+ * (if result == in). 0 < shift < 8.
+ */
+u8 vli_lshift(u8 *result, u8 *in, u32 shift);
+
+/* Computes vli = vli >> 1. */
+void vli_rshift1(u8 *vli);
+
+/* Computes result = left + right, returning carry. Can modify in place. */
+u8 vli_add(u8 *result, u8 *left, u8 *right);
+
+/* Computes result = left - right, returning borrow. Can modify in place. */
+u8 vli_sub(u8 *result, u8 *left, u8 *right);
+
+/* Computes result = left * right. */
+void vli_mult(u8 *result, u8 *left, u8 *right);
+
+/* Computes result = left^2. */
+void vli_square(u8 *result, u8 *left);
+
+/* Computes result = (left + right) % mod.
+   Assumes that left < mod and right < mod, result != mod. */
+void vli_mod_add(u8 *result, u8 *left, u8 *right, u8 *mod);
+
+/* Computes result = (left - right) % mod.
+   Assumes that left < mod and right < mod, result != mod. */
+void vli_mod_sub(u8 *result, u8 *left, u8 *right, u8 *mod);
+
+/* Computes result = (left * right) % ecc_curve.p. */
+void vli_mod_mult_fast(u8 *result, u8 *left, u8 *right, u8 *mod);
+
+/* Computes result = left^2 % ecc_curve.p. */
+void vli_mod_square_fast(u8 *result, u8 *left, u8 *mod);
+
+/* Computes result = (left * right) % mod. */
+void vli_mod_mult(u8 *result, u8 *left, u8 *right, u8 *mod);
+
+/* Computes result = (1 / input) % mod. All VLIs are the same size.
+ * See "From Euclid's GCD to Montgomery Multiplication to the Great Divide"
+ * https://labs.oracle.com/techrep/2001/smli_tr-2001-95.pdf
+ */
+void vli_mod_inv(u8 *result, u8 *input, u8 *mod);
+
+
+#endif
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/private_include/random.h b/src/libstrongswan/plugins/gmalg/gmalg/private_include/random.h
new file mode 100644
index 000000000..1f16e1a43
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/private_include/random.h
@@ -0,0 +1,10 @@
+
+#ifndef _RANDOM_H_
+#define _RANDOM_H_
+
+#include "typedef.h"
+
+
+int vli_get_random(u8 *p_data, u32 len);
+
+#endif
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm2.h b/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm2.h
new file mode 100644
index 000000000..77b10c986
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm2.h
@@ -0,0 +1,33 @@
+#ifndef _SM2_H_
+#define _SM2_H_
+
+#include "typedef.h"
+#include "ecc.h"
+
+int sm2_make_prikey(u8 *prikey);
+int sm2_make_pubkey(u8 *prikey, ecc_point *pubkey);
+int sm2_make_keypair(u8 *prikey, ecc_point *pubkey);
+int sm2_sign(u8 *r, u8 *s, u8 *pri, u8 *hash);
+int sm2_verify(ecc_point *pubkey, u8 *hash, u8 *r, u8 *s);
+int sm2_encrypt(ecc_point *pubKey, u8 *M, u32 Mlen, u8 *C, u32 *Clen);
+int sm2_decrypt(u8 *prikey, u8 *C, u32 Clen, u8 *M, u32 *Mlen);
+
+void sm3_z(u8 *id, u32 idlen, ecc_point *pub, u8 *hash);
+int sm2_shared_point(u8* selfPriKey,  u8* selfTempPriKey, ecc_point* selfTempPubKey,
+		 ecc_point *otherPubKey, ecc_point* otherTempPubKey, ecc_point *key);
+int sm2_shared_key(ecc_point *point, u8 *ZA, u8 *ZB, u32 keyLen, u8 *key);
+int sm2_point_mult(ecc_point *G, u8 *k, ecc_point *P);
+
+
+int ECC_KeyEx_Init_I(u8 *pri, ecc_point *pub);
+
+int ECC_KeyEx_Re_I(u8 *rb, u8 *dB, ecc_point *RA, ecc_point *PA,
+		u8* ZA, u8 *ZB, u8 *K, u32 klen, ecc_point *RB,
+		ecc_point *V, u8* hash);
+
+int ECC_KeyEx_Init_II(u8* ra, u8* dA, ecc_point* RA, ecc_point* RB, ecc_point* PB, u8
+		ZA[],u8 ZB[],u8 SB[],u8 K[], u32 klen,u8 SA[]);
+
+int ECC_KeyEx_Re_II(ecc_point *V,ecc_point *RA,ecc_point *RB,u8 ZA[],u8 ZB[],u8 SA[]);
+
+#endif /* _SM2_H_ */
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm3.h b/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm3.h
new file mode 100644
index 000000000..f7106e3b9
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm3.h
@@ -0,0 +1,19 @@
+#ifndef _SM3_H_
+#define _SM3_H_
+
+#include <stdint.h>
+#include "typedef.h"
+
+typedef struct {
+	uint32_t total[2];    /*!< number of bytes processed  */
+	uint32_t state[8];    /*!< intermediate digest state  */
+	uint8_t buffer[64];   /*!< data block being processed */
+	uint8_t ipad[64];     /*!< HMAC: inner padding        */
+	uint8_t opad[64];     /*!< HMAC: outer padding        */
+} sm3_ctx;
+
+int sm3_init(sm3_ctx *ctx);
+int sm3_update(sm3_ctx *ctx, const uint8_t *input, uint32_t ilen);
+int sm3_finish(sm3_ctx *ctx, uint8_t *output);
+
+#endif /* _SM3_H_ */
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm4.h b/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm4.h
new file mode 100644
index 000000000..964acab10
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/private_include/sm4.h
@@ -0,0 +1,16 @@
+#ifndef _SM4_H_
+#define _SM4_H_
+
+#include "typedef.h"
+
+typedef struct {
+	u32 sk_enc[32];
+	u32 sk_dec[32];
+} sm4_ctx;
+
+void sm4_ecb_encrypt(sm4_ctx *ctx, u8 *key, u8 *in, u8 len, u8 *out);
+void sm4_ecb_decrypt(sm4_ctx *ctx, u8 *key, u8 *in, u8 len, u8 *out);
+void sm4_cbc_encrypt(sm4_ctx *ctx, u8 *key, u8 *iv, u8 *in, u8 len, u8 *out);
+void sm4_cbc_decrypt(sm4_ctx *ctx, u8 *key, u8 *iv, u8 *in, u8 len, u8 *out);
+
+#endif /* _SM4_H_ */
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/private_include/typedef.h b/src/libstrongswan/plugins/gmalg/gmalg/private_include/typedef.h
new file mode 100644
index 000000000..3c07ec589
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/private_include/typedef.h
@@ -0,0 +1,16 @@
+#ifndef __TYPEDEF_H__
+#define __TYPEDEF_H__
+
+#include <netinet/in.h>
+
+typedef	unsigned char		u8;
+typedef	unsigned short		u16;
+typedef	unsigned int		u32;
+typedef	unsigned long long	u64;
+
+typedef char			s8;
+typedef	short			s16;
+typedef int			s32;
+typedef long long		s64;
+
+#endif
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/random.c b/src/libstrongswan/plugins/gmalg/gmalg/random.c
new file mode 100644
index 000000000..bbadc4315
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/random.c
@@ -0,0 +1,24 @@
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+
+#include "debug.h"
+#include "random.h"
+
+int vli_get_random(u8 *data, u32 len)
+{
+	int fd = open("/dev/urandom", O_RDONLY);
+	int ret = -1;
+
+	if (fd > 0) {
+		ret = read(fd, data, len);
+		close(fd);
+
+	}
+
+	return ret;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/sm2.c b/src/libstrongswan/plugins/gmalg/gmalg/sm2.c
new file mode 100644
index 000000000..db25dca4b
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/sm2.c
@@ -0,0 +1,595 @@
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "debug.h"
+#include "random.h"
+#include "ecc.h"
+#include "sm2.h"
+#include "sm3.h"
+
+struct ecc_curve ecc_curve = {
+	.g = {
+		.x = {
+			0xC7, 0x74, 0x4C, 0x33, 0x89, 0x45, 0x5A, 0x71, 0xE1, 0x0B, 0x66, 0xF2, 0xBF, 0x0B, 0xE3, 0x8F,
+			0x94, 0xC9, 0x39, 0x6A, 0x46, 0x04, 0x99, 0x5F, 0x19, 0x81, 0x19, 0x1F, 0x2C, 0xAE, 0xC4, 0x32},
+		.y = {
+			0xA0, 0xF0, 0x39, 0x21, 0xE5, 0x32, 0xDF, 0x02, 0x40, 0x47, 0x2A, 0xC6, 0x7C, 0x87, 0xA9, 0xD0,
+			0x53, 0x21, 0x69, 0x6B, 0xE3, 0xCE, 0xBD, 0x59, 0x9C, 0x77, 0xF6, 0xF4, 0xA2, 0x36, 0x37, 0xBC},
+	},
+	.p = {
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF},
+	.n = {
+		0x23, 0x41, 0xD5, 0x39, 0x09, 0xF4, 0xBB, 0x53, 0x2B, 0x05, 0xC6, 0x21, 0x6B, 0xDF, 0x03, 0x72,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF},
+	.h = {
+		0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	.a = {
+		0xfc,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
+		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0xff,0xff,0xff,0xff, 0xfe,0xff,0xff,0xff},
+	.b = {
+		0x93, 0x0E, 0x94, 0x4D, 0x41, 0xBD, 0xBC, 0xDD, 0x92, 0x8F, 0xAB, 0x15, 0xF5, 0x89, 0x97, 0xF3,
+		0xA7, 0x09, 0x65, 0xCF, 0x4B, 0x9E, 0x5A, 0x4D, 0x34, 0x5E, 0x9F, 0x9D, 0x9E, 0xFA, 0xE9, 0x28},
+};
+
+void ecc_bytes2native(u8 *native, u8 *bytes)
+{
+	unsigned int i;
+
+	for (i = 0; i < ECC_NUMWORD/2; ++i) {
+		if (native == bytes) {
+			u8 temp;
+
+			temp = native[i];
+			native[i] = bytes[ECC_NUMWORD - i - 1];
+			bytes[ECC_NUMWORD - i - 1] = temp;
+		}else {
+			native[i] = bytes[ECC_NUMWORD - i - 1];
+			native[ECC_NUMWORD - i - 1] = bytes[i];
+		}
+	}
+}
+
+void ecc_native2bytes(u8 *bytes, u8 *native)
+{
+	unsigned int i;
+
+	for (i = 0; i < ECC_NUMWORD/2; ++i) {
+		if (bytes == native) {
+			u8 temp;
+			temp = bytes[ECC_NUMWORD - i - 1];
+			bytes[ECC_NUMWORD - i - 1] = native[i];
+			native[i] = temp;
+		} else {
+			bytes[i] = native[ECC_NUMWORD - i - 1];
+			bytes[ECC_NUMWORD - i - 1] = native[i];
+		}
+	}
+}
+
+/*x¯2 = 2w + (x2&(2w − 1))*/
+void sm2_w(u8 *result, u8 *x)
+{
+	memcpy(result, x, 16);
+	result[15] |= 0x80;
+	memset(result + 16, 0, 16);
+}
+
+void sm3_kdf(u8 *Z ,u32 zlen, u8 *K, u32 klen)
+{
+	u32 ct = 0x00000001;
+	u8 ct_char[32];
+	u8 *hash = K ;
+	u32 i, t;
+	sm3_ctx md[1];
+
+	t = klen/ECC_NUMWORD;
+	//s4: K=Ha1||Ha2||...
+	for (i = 0; i < t; i++) {
+		//s2: Hai=Hv(Z||ct)
+		sm3_init(md);
+		sm3_update(md, Z, zlen);
+		digit2str32(ct, ct_char);
+		sm3_update(md, ct_char, 4);
+		sm3_finish(md, hash);
+		hash += 32;
+		ct++;
+	}
+
+	t = klen%ECC_NUMBITS;
+	if (t) {
+		sm3_init(md);
+		sm3_update(md, Z, zlen);
+		digit2str32(ct, ct_char);
+		sm3_update(md, ct_char, 4);
+		sm3_finish(md, ct_char);
+		memcpy(hash, ct_char, t);
+	}
+}
+
+void sm3_z(u8 *id, u32 idlen, ecc_point *pub, u8 *hash)
+{
+	u8 a[ECC_NUMWORD];
+	u8 b[ECC_NUMWORD];
+	u8 x[ECC_NUMWORD];
+	u8 y[ECC_NUMWORD];
+	u8 idlen_char[2];
+	sm3_ctx md[1];
+
+	digit2str16(idlen<<3, idlen_char);
+
+	ecc_bytes2native(a, ecc_curve.a);
+	ecc_bytes2native(b, ecc_curve.b);
+	ecc_bytes2native(x, ecc_curve.g.x);
+	ecc_bytes2native(y, ecc_curve.g.y);
+
+	sm3_init(md);
+	sm3_update(md, idlen_char, 2);
+	sm3_update(md, id, idlen);
+	sm3_update(md, a, ECC_NUMWORD);
+	sm3_update(md, b, ECC_NUMWORD);
+	sm3_update(md, x, ECC_NUMWORD);
+	sm3_update(md, y, ECC_NUMWORD);
+	sm3_update(md, pub->x, ECC_NUMWORD);
+	sm3_update(md, pub->y, ECC_NUMWORD);
+	sm3_finish(md, hash);
+
+	return;
+}
+
+int ecc_valid_public_key(ecc_point *publicKey)
+{
+	u8 na[ECC_NUMWORD] = {3}; /* a mod p = (-3) mod p */
+	u8 tmp1[ECC_NUMWORD];
+	u8 tmp2[ECC_NUMWORD];
+
+	if (ecc_point_is_zero(publicKey))
+		return 1;
+
+	if (vli_cmp(ecc_curve.p, publicKey->x) != 1 || vli_cmp(ecc_curve.p, publicKey->y) != 1)
+		return 1;
+
+	vli_mod_square_fast(tmp1, publicKey->y, ecc_curve.p); /* tmp1 = y^2 */
+	vli_mod_square_fast(tmp2, publicKey->x, ecc_curve.p); /* tmp2 = x^2 */
+	vli_mod_sub(tmp2, tmp2, na, ecc_curve.p);  /* tmp2 = x^2 + a = x^2 - 3 */
+	vli_mod_mult_fast(tmp2, tmp2, publicKey->x, ecc_curve.p); /* tmp2 = x^3 + ax */
+	vli_mod_add(tmp2, tmp2, ecc_curve.b, ecc_curve.p); /* tmp2 = x^3 + ax + b */
+
+	/* Make sure that y^2 == x^3 + ax + b */
+	if (vli_cmp(tmp1, tmp2) != 0)
+		return 1;
+
+	return 0;
+}
+
+int sm2_make_prikey(u8 *prikey)
+{
+	ecc_point pub[1];
+	u8 pri[ECC_NUMWORD];
+	int i = 10;
+
+	do {
+		vli_get_random(pri, ECC_NUMWORD);
+		if(vli_cmp(ecc_curve.n, pri) != 1) {
+			vli_sub(pri, pri, ecc_curve.n);
+		}
+
+		/* The private key cannot be 0 (mod p). */
+		if(!vli_is_zero(pri)) {
+			ecc_bytes2native(prikey, pri);
+			return 0;
+		}
+	} while(i--);
+
+	return -1;
+}
+
+int sm2_make_pubkey(u8 *prikey, ecc_point *pubkey)
+{
+	ecc_point pub[1];
+	u8 pri[ECC_NUMWORD];
+
+	ecc_bytes2native(pri, prikey);
+	ecc_point_mult(pub, &ecc_curve.g, pri, NULL);
+	ecc_bytes2native(pubkey->x, pub->x);
+	ecc_bytes2native(pubkey->y, pub->y);
+
+	return 0;
+}
+
+int sm2_make_keypair(u8 *prikey, ecc_point *pubkey)
+{
+	sm2_make_prikey(prikey);
+	sm2_make_pubkey(prikey, pubkey);
+	return 0;
+}
+
+int sm2_point_mult(ecc_point *G, u8 *k, ecc_point *P)
+{
+	int rc = 0;
+
+	ecc_point G_[1];
+	ecc_point P_[1];
+	u8 k_[ECC_NUMWORD];
+
+	ecc_bytes2native(k_, k);
+	ecc_bytes2native(G_->x, G->x);
+	ecc_bytes2native(G_->y, G->y);
+
+	ecc_point_mult(P_, G_, k_, NULL);
+
+	ecc_bytes2native(P->x, P_->x);
+	ecc_bytes2native(P->y, P_->y);
+
+	return rc;
+}
+
+int sm2_sign(u8 *r, u8 *s, u8 *prikey, u8 *hash)
+{
+	u8 k[ECC_NUMWORD];
+	u8 one[ECC_NUMWORD] = {1};
+	u8 random[ECC_NUMWORD];
+	u8 pri[ECC_NUMWORD];
+	ecc_point p;
+
+	vli_set(pri, prikey);
+	ecc_bytes2native(pri, pri);
+
+	vli_get_random(random, ECC_NUMWORD);
+	if (vli_is_zero(random)) {
+		/* The random number must not be 0. */
+		return 0;
+	}
+
+	vli_set(k, random);
+	if (vli_cmp(ecc_curve.n, k) != 1) {
+		vli_sub(k, k, ecc_curve.n);
+	}
+
+	/* tmp = k * G */
+	ecc_point_mult(&p, &ecc_curve.g, k, NULL);
+
+	/* r = x1 + e (mod n) */
+	vli_set(r, p.x);
+	vli_mod_add(r, r, hash, ecc_curve.n);
+	if (vli_cmp(ecc_curve.n, r) != 1) {
+		vli_sub(r, r, ecc_curve.n);
+	}
+
+	if (vli_is_zero(r)) {
+		/* If r == 0, fail (need a different random number). */
+		return 0;
+	}
+
+	vli_mod_mult(s, r, pri, ecc_curve.n); /* s = r*d */
+	vli_mod_sub(s, k, s, ecc_curve.n); /* k-r*d */
+	vli_mod_add(pri, pri, one, ecc_curve.n); /* 1+d */
+	vli_mod_inv(pri, pri, ecc_curve.n); /* (1+d)' */
+	vli_mod_mult(s, pri, s, ecc_curve.n); /* (1+d)'*(k-r*d) */
+
+	ecc_bytes2native(r, r);
+	ecc_bytes2native(s, s);
+
+	return 1;
+}
+
+int sm2_verify(ecc_point *pubkey, u8 *hash, u8 *r, u8 *s)
+{
+	ecc_point result;
+	u8 t[ECC_NUMWORD];
+	ecc_point pub[1];
+
+	vli_set(pub->x, pubkey->x);
+	vli_set(pub->y, pubkey->y);
+
+	ecc_bytes2native(pub->x, pub->x);
+	ecc_bytes2native(pub->y, pub->y);
+	ecc_bytes2native(r, r);
+	ecc_bytes2native(s, s);
+
+	if (vli_is_zero(r) || vli_is_zero(s)) {
+		/* r, s must not be 0. */
+		return -1;
+	}
+
+	if (vli_cmp(ecc_curve.n, r) != 1 || vli_cmp(ecc_curve.n, s) != 1) {
+		/* r, s must be < n. */
+		return -1;
+	}
+
+	vli_mod_add(t, r, s, ecc_curve.n); // r + s
+	if (t == 0)
+		return -1;
+
+	ecc_point_mult2(&result, &ecc_curve.g, pub, s, t);
+
+	/* v = x1 + e (mod n) */
+	vli_mod_add(result.x, result.x, hash, ecc_curve.n);
+
+	if(vli_cmp(ecc_curve.n, result.x) != 1) {
+		vli_sub(result.x, result.x, ecc_curve.n);
+	}
+
+	/* Accept only if v == r. */
+	return vli_cmp(result.x, r);
+}
+
+int sm2_encrypt(ecc_point *pubKey, u8 *M, u32 Mlen, u8 *C, u32 *Clen)
+{
+	u8 k[ECC_NUMWORD];
+	u8 t[ECC_NUMWORD];
+	ecc_point pub[1];
+	ecc_point *C1 = (ecc_point *)C;
+	u8 *C2 = C + ECC_NUMWORD*2;
+	u8 *C3 = C + ECC_NUMWORD*2 + Mlen;
+
+	ecc_point kP;
+	u8 *x2 = kP.x;
+	u8 *y2 = kP.y;
+	u8 *x2y2 = x2;
+	sm3_ctx md[1];
+	int i=0;
+
+	ecc_bytes2native(pub->x, pubKey->x);
+	ecc_bytes2native(pub->y, pubKey->y);
+
+	vli_get_random(k, ECC_NUMWORD);
+
+	/* C1 = k * G */
+	ecc_point_mult(C1, &ecc_curve.g, k, NULL);
+	ecc_bytes2native(C1->x, C1->x);
+	ecc_bytes2native(C1->y, C1->y);
+	/*vli_set(C, C1->x);*/
+	/*vli_set(C+ECC_NUMWORD, C1->y);*/
+
+	/* S = h * Pb */
+	ecc_point S;
+	ecc_point_mult(&S, pub, ecc_curve.h, NULL);
+	if (ecc_valid_public_key(&S) != 0)
+		return -1;
+
+	/* kP = k * Pb */
+	ecc_point_mult(&kP, pub, k, NULL);
+	ecc_bytes2native(x2, x2);
+	ecc_bytes2native(y2, y2);
+	/*vli_set(x2, kP.x);*/
+	/*vli_set(y2, kP.y);*/
+
+	/* t=KDF(x2 ∥ y2, klen) */
+	sm3_kdf(x2y2, ECC_NUMWORD*2, t, Mlen);
+	if (vli_is_zero(x2) | vli_is_zero(y2)) {
+		return 0;
+	}
+
+	/* C2 = M ⊕ t；*/
+	for (i = 0; i < Mlen; i++) {
+		C2[i] = M[i]^t[+i];
+	}
+
+	/*C3 = Hash(x2 ∥ M ∥ y2)*/
+	sm3_init(md);
+	sm3_update(md, x2, ECC_NUMWORD);
+	sm3_update(md, M, Mlen);
+	sm3_update(md, y2, ECC_NUMWORD);
+	sm3_finish(md, C3);
+
+	if (Clen)
+		*Clen = Mlen + ECC_NUMWORD*2 + ECC_NUMWORD;
+
+	return 0;
+}
+
+int sm2_decrypt(u8 *prikey, u8 *C, u32 Clen, u8 *M, u32 *Mlen)
+{
+	u8 hash[ECC_NUMWORD];
+	u8 pri[ECC_NUMWORD];
+	ecc_point *C1 = (ecc_point *)C;
+	u8 *C2 = C + ECC_NUMWORD*2;
+	u8 *C3 = C + Clen - ECC_NUMWORD;
+	ecc_point dB;
+	u8 *x2 = dB.x;
+	u8 *y2 = dB.y;
+	u8 *x2y2 = x2;
+	sm3_ctx md[1];
+	int outlen = Clen-ECC_NUMWORD*3;
+	int i=0;
+
+	ecc_bytes2native(pri, prikey);
+	ecc_bytes2native(C1->x, C1->x);
+	ecc_bytes2native(C1->y, C1->y);
+
+	if (ecc_valid_public_key(C1) != 0)
+		return -1;
+
+	ecc_point S;
+	ecc_point_mult(&S, C1, ecc_curve.h, NULL);
+	if (ecc_valid_public_key(&S) != 0)
+		return -1;
+
+	ecc_point_mult(&dB, C1, pri, NULL);
+	ecc_bytes2native(x2, x2);
+	ecc_bytes2native(y2, y2);
+
+	sm3_kdf(x2y2, ECC_NUMWORD*2, M, outlen);
+	if (vli_is_zero(x2) | vli_is_zero(y2)) {
+		return 0;
+	}
+
+	for (i = 0; i < outlen; i++)
+		M[i]=M[i]^C2[i];
+
+	sm3_init(md);
+	sm3_update(md, x2, ECC_NUMWORD);
+	sm3_update(md, M, outlen);
+	sm3_update(md, y2, ECC_NUMWORD);
+	sm3_finish(md, hash);
+
+	*Mlen = outlen;
+	if (memcmp(hash , C3, ECC_NUMWORD) != 0)
+		return -1;
+	else
+		return 0;
+}
+
+int sm2_shared_point(u8* selfPriKey,  u8* selfTempPriKey, ecc_point* selfTempPubKey,
+		 ecc_point *otherPubKey, ecc_point* otherTempPubKey, ecc_point *key)
+{
+	ecc_point selfTempPub;
+	ecc_point otherTempPub;
+	ecc_point otherPub;
+	ecc_point U[1];
+
+	u8 selfTempPri[ECC_NUMWORD];
+	u8 selfPri[ECC_NUMWORD];
+	u8 temp1[ECC_NUMWORD];
+	u8 temp2[ECC_NUMWORD];
+	u8 tA[ECC_NUMWORD];
+
+	ecc_bytes2native(selfTempPri, selfTempPriKey);
+	ecc_bytes2native(selfPri, selfPriKey);
+	ecc_bytes2native(selfTempPub.x, selfTempPubKey->x);
+	ecc_bytes2native(selfTempPub.y, selfTempPubKey->y);
+	ecc_bytes2native(otherTempPub.x, otherTempPubKey->x);
+	ecc_bytes2native(otherTempPub.y, otherTempPubKey->y);
+	ecc_bytes2native(otherPub.x, otherPubKey->x);
+	ecc_bytes2native(otherPub.y, otherPubKey->y);
+
+	/***********x1_=2^w+x2 & (2^w-1)*************/
+	sm2_w(temp1, selfTempPub.x);
+	/***********tA=(dA+x1_*rA)mod n *************/
+	vli_mod_mult(temp1, selfTempPri, temp1, ecc_curve.n);
+	vli_mod_add(tA, selfPri, temp1, ecc_curve.n);
+	/***********x2_=2^w+x2 & (2^w-1)*************/
+	if(ecc_valid_public_key(&otherTempPub) != 0)
+		return -1;
+	sm2_w(temp2, otherTempPub.x);
+	/**************U=[h*tA](PB+[x2_]RB)**********/
+	ecc_point_mult(U, &otherTempPub, temp2, NULL);/* U=[x2_]RB */
+	ecc_point_add(U, &otherPub, U); /*U=PB+U*/
+	vli_mod_mult(tA, tA, ecc_curve.h, ecc_curve.n); /*tA=tA*h */
+	ecc_point_mult(U, U,tA, NULL);
+
+	ecc_bytes2native(key->x, U->x);
+	ecc_bytes2native(key->y, U->y);
+}
+
+int sm2_shared_key(ecc_point *point, u8 *ZA, u8 *ZB, u32 keyLen, u8 *key)
+{
+	u8 Z[ECC_NUMWORD*4];
+	memcpy(Z, point->x, ECC_NUMWORD);
+	memcpy(Z + ECC_NUMWORD, point->y, ECC_NUMWORD);
+	memcpy(Z + ECC_NUMWORD*2, ZA, ECC_NUMWORD);
+	memcpy(Z + ECC_NUMWORD*3, ZB, ECC_NUMWORD);
+	sm3_kdf(Z, ECC_NUMWORD*4, key, keyLen);
+}
+
+/****hash = Hash(Ux||ZA||ZB||x1||y1||x2||y2)****/
+int ECC_Key_ex_hash1(u8* x, ecc_point *RA, ecc_point* RB, u8 ZA[],u8 ZB[],u8 *hash)
+{
+	sm3_ctx md[1];
+
+	sm3_init(md);
+	sm3_update(md, x, ECC_NUMWORD);
+	sm3_update(md, ZA, ECC_NUMWORD);
+	sm3_update(md, ZB, ECC_NUMWORD);
+	sm3_update(md, RA->x, ECC_NUMWORD);
+	sm3_update(md, RA->y, ECC_NUMWORD);
+	sm3_update(md, RB->x, ECC_NUMWORD);
+	sm3_update(md, RB->y, ECC_NUMWORD);
+	sm3_finish(md, hash);
+
+	return 0;
+}
+
+/****SA = Hash(temp||Uy||Hash)****/
+int ECC_Key_ex_hash2(u8 temp, u8* y,u8 *hash, u8* SA)
+{
+	sm3_ctx md[1];
+
+	sm3_init(md);
+	sm3_update(md, &temp,1);
+	sm3_update(md, y,ECC_NUMWORD);
+	sm3_update(md, hash,ECC_NUMWORD);
+	sm3_finish(md, SA);
+
+	return 0;
+}
+
+int ECC_KeyEx_Init_I(u8 *pri, ecc_point *pub)
+{
+	return sm2_make_pubkey(pri, pub);
+}
+
+int ECC_KeyEx_Re_I(u8 *rb, u8 *dB, ecc_point *RA, ecc_point *PA, u8* ZA, u8 *ZB, u8 *K, u32 klen, ecc_point *RB, ecc_point *V, u8* SB)
+{
+	sm3_ctx md[1];
+	u8 Z[ECC_NUMWORD*2 + ECC_NUMBITS/4]={0};
+	u8 hash[ECC_NUMWORD],S1[ECC_NUMWORD];
+	u8 temp=0x02;
+
+	//--------B2: RB=[rb]G=(x2,y2)--------
+	sm2_make_pubkey(rb, RB);
+	/********************************************/
+	sm2_shared_point(dB,  rb, RB, PA, RA, V);
+	//------------B7:KB=KDF(VX,VY,ZA,ZB,KLEN)----------
+	memcpy(Z, V->x, ECC_NUMWORD);
+	memcpy(Z+ECC_NUMWORD, V->y, ECC_NUMWORD);
+	memcpy(Z+ECC_NUMWORD*2, ZA,ECC_NUMWORD);
+	memcpy(Z+ECC_NUMWORD*3, ZB,ECC_NUMWORD);
+	sm3_kdf(Z,ECC_NUMWORD*4, K, klen);
+	//---------------B8:(optional) SB=hash(0x02||Vy||HASH(Vx||ZA||ZB||x1||y1||x2||y2)-------------
+	ECC_Key_ex_hash1(V->x,  RA, RB, ZA, ZB, hash);
+	ECC_Key_ex_hash2(temp, V->y, hash, SB);
+
+	return 0;
+}
+
+int ECC_KeyEx_Init_II(u8* ra, u8* dA, ecc_point* RA, ecc_point* RB, ecc_point* PB, u8
+		ZA[],u8 ZB[],u8 SB[],u8 K[], u32 klen,u8 SA[])
+{
+	sm3_ctx md[1];
+	u8 Z[ECC_NUMWORD*2 + ECC_NUMWORD*2]={0};
+	u8 hash[ECC_NUMWORD],S1[ECC_NUMWORD];
+	u8 temp[2]={0x02,0x03};
+	ecc_point U[1];
+
+	/********************************************/
+	sm2_shared_point(dA, ra, RA, PB, RB, U);
+	/************KA=KDF(UX,UY,ZA,ZB,KLEN)**********/
+	memcpy(Z, U->x,ECC_NUMWORD);
+	memcpy(Z+ECC_NUMWORD, U->y,ECC_NUMWORD);
+	memcpy(Z+ECC_NUMWORD*2,ZA,ECC_NUMWORD);
+	memcpy(Z+ECC_NUMWORD*2 +ECC_NUMWORD ,ZB,ECC_NUMWORD);
+	sm3_kdf(Z,ECC_NUMWORD*2+ECC_NUMWORD*2, K, klen);
+	/****S1 = Hash(0x02||Uy||Hash(Ux||ZA||ZB||x1||y1||x2||y2))****/
+	ECC_Key_ex_hash1(U->x,  RA, RB, ZA, ZB, hash);
+	ECC_Key_ex_hash2(temp[0], U->y, hash, S1);
+	/*test S1=SB?*/
+	if( memcmp(S1,SB,ECC_NUMWORD)!=0)
+		return -1;
+	/*SA = Hash(0x03||yU||Hash(xU||ZA||ZB||x1||y1||x2||y2)) */
+	ECC_Key_ex_hash2(temp[1], U->y, hash, SA);
+
+	return 0;
+}
+
+int ECC_KeyEx_Re_II(ecc_point *V, ecc_point *RA, ecc_point *RB, u8 ZA[], u8 ZB[], u8 SA[])
+{
+	u8 hash[ECC_NUMWORD];
+	u8 S2[ECC_NUMWORD];
+	u8 temp=0x03;
+	sm3_ctx md[1];
+
+	/*S2 = Hash(0x03||Vy||Hash(Vx||ZA||ZB||x1||y1||x2||y2))*/
+	ECC_Key_ex_hash1(V->x,  RA, RB, ZA, ZB, hash);
+	ECC_Key_ex_hash2(temp, V->y, hash, S2);
+
+	if( memcmp(S2,SA,ECC_NUMWORD)!=0)
+		return -1;
+
+	return 0;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/sm3.c b/src/libstrongswan/plugins/gmalg/gmalg/sm3.c
new file mode 100644
index 000000000..554f70c43
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/sm3.c
@@ -0,0 +1,327 @@
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+
+#include "debug.h"
+#include "sm3.h"
+
+/*
+ * 32-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_ULONG_BE
+#define GET_ULONG_BE(n,b,i)                      \
+{                                                \
+	(n) =     ( (u32) (b)[(i)    ] << 24 )   \
+		| ( (u32) (b)[(i) + 1] << 16 )   \
+		| ( (u32) (b)[(i) + 2] <<  8 )   \
+		| ( (u32) (b)[(i) + 3]       );  \
+}
+#endif
+
+#ifndef PUT_ULONG_BE
+#define PUT_ULONG_BE(n,b,i)                   \
+{                                             \
+	(b)[(i)    ] = (u8) ( (n) >> 24 );    \
+	(b)[(i) + 1] = (u8) ( (n) >> 16 );    \
+	(b)[(i) + 2] = (u8) ( (n) >>  8 );    \
+	(b)[(i) + 3] = (u8) ( (n)       );    \
+}
+#endif
+
+/*
+ * SM3 context setup
+ */
+int sm3_init(sm3_ctx *ctx)
+{
+	ctx->total[0] = 0;
+	ctx->total[1] = 0;
+
+	ctx->state[0] = 0x7380166F;
+	ctx->state[1] = 0x4914B2B9;
+	ctx->state[2] = 0x172442D7;
+	ctx->state[3] = 0xDA8A0600;
+	ctx->state[4] = 0xA96F30BC;
+	ctx->state[5] = 0x163138AA;
+	ctx->state[6] = 0xE38DEE4D;
+	ctx->state[7] = 0xB0FB0E4E;
+
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+	return 0;
+}
+
+static void sm3_process(sm3_ctx *ctx, u8 data[64])
+{
+	u32 SS1, SS2, TT1, TT2, W[68],W1[64];
+	u32 A, B, C, D, E, F, G, H;
+	u32 T[64];
+	u32 Temp1,Temp2,Temp3,Temp4,Temp5;
+	int j;
+#if ALG_DEBUG
+	int i;
+#endif
+
+	//for(j=0; j < 68; j++)
+	//	W[j] = 0;
+	//for(j=0; j < 64; j++)
+	//	W1[j] = 0;
+
+	for(j = 0; j < 16; j++)
+		T[j] = 0x79CC4519;
+	for(j =16; j < 64; j++)
+		T[j] = 0x7A879D8A;
+
+	GET_ULONG_BE( W[ 0], data,  0 );
+	GET_ULONG_BE( W[ 1], data,  4 );
+	GET_ULONG_BE( W[ 2], data,  8 );
+	GET_ULONG_BE( W[ 3], data, 12 );
+	GET_ULONG_BE( W[ 4], data, 16 );
+	GET_ULONG_BE( W[ 5], data, 20 );
+	GET_ULONG_BE( W[ 6], data, 24 );
+	GET_ULONG_BE( W[ 7], data, 28 );
+	GET_ULONG_BE( W[ 8], data, 32 );
+	GET_ULONG_BE( W[ 9], data, 36 );
+	GET_ULONG_BE( W[10], data, 40 );
+	GET_ULONG_BE( W[11], data, 44 );
+	GET_ULONG_BE( W[12], data, 48 );
+	GET_ULONG_BE( W[13], data, 52 );
+	GET_ULONG_BE( W[14], data, 56 );
+	GET_ULONG_BE( W[15], data, 60 );
+
+#if ALG_DEBUG
+	printf("Message with padding:\n");
+	for(i=0; i< 8; i++)
+		printf("%08x ",W[i]);
+	printf("\n");
+	for(i=8; i< 16; i++)
+		printf("%08x ",W[i]);
+	printf("\n");
+#endif
+
+#define FF0(x,y,z) ( (x) ^ (y) ^ (z))
+#define FF1(x,y,z) (((x) & (y)) | ( (x) & (z)) | ( (y) & (z)))
+
+#define GG0(x,y,z) ( (x) ^ (y) ^ (z))
+#define GG1(x,y,z) (((x) & (y)) | ( (~(x)) & (z)) )
+
+
+#define SHL(x,n) (((x) & 0xFFFFFFFF) << n)
+#define ROTL(x,n) (SHL((x),n) | ((x) >> (32 - n)))
+//#define ROTL(x,n) (SHL((x),n) | ((x) >> (32 - n%32)))
+
+#define P0(x) ((x) ^  ROTL((x),9) ^ ROTL((x),17))
+#define P1(x) ((x) ^  ROTL((x),15) ^ ROTL((x),23))
+
+	for(j = 16; j < 68; j++ )
+	{
+		//W[j] = P1( W[j-16] ^ W[j-9] ^ ROTL(W[j-3],15)) ^ ROTL(W[j - 13],7 ) ^ W[j-6];
+		//Why thd release's result is different with the debug's ?
+		//Below is okay. Interesting, Perhaps VC6 has a bug of Optimizaiton.
+
+		Temp1 = W[j-16] ^ W[j-9];
+		Temp2 = ROTL(W[j-3],15);
+		Temp3 = Temp1 ^ Temp2;
+		Temp4 = P1(Temp3);
+		Temp5 =  ROTL(W[j - 13],7 ) ^ W[j-6];
+		W[j] = Temp4 ^ Temp5;
+	}
+
+#if ALG_DEBUG
+	printf("Expanding message W0-67:\n");
+	for(i=0; i<68; i++)
+	{
+		printf("%08x ",W[i]);
+		if(((i+1) % 8) == 0) printf("\n");
+	}
+	printf("\n");
+#endif
+
+	for(j =  0; j < 64; j++)
+	{
+		W1[j] = W[j] ^ W[j+4];
+	}
+
+#if ALG_DEBUG
+	printf("Expanding message W'0-63:\n");
+	for(i=0; i<64; i++)
+	{
+		printf("%08x ",W1[i]);
+		if(((i+1) % 8) == 0) printf("\n");
+	}
+	printf("\n");
+#endif
+
+	A = ctx->state[0];
+	B = ctx->state[1];
+	C = ctx->state[2];
+	D = ctx->state[3];
+	E = ctx->state[4];
+	F = ctx->state[5];
+	G = ctx->state[6];
+	H = ctx->state[7];
+#if ALG_DEBUG
+	printf("j     A       B        C         D         E        F        G       H\n");
+	printf("   %08x %08x %08x %08x %08x %08x %08x %08x\n",A,B,C,D,E,F,G,H);
+#endif
+
+	for(j =0; j < 16; j++)
+	{
+		SS1 = ROTL((ROTL(A,12) + E + ROTL(T[j],j)), 7);
+		SS2 = SS1 ^ ROTL(A,12);
+		TT1 = FF0(A,B,C) + D + SS2 + W1[j];
+		TT2 = GG0(E,F,G) + H + SS1 + W[j];
+		D = C;
+		C = ROTL(B,9);
+		B = A;
+		A = TT1;
+		H = G;
+		G = ROTL(F,19);
+		F = E;
+		E = P0(TT2);
+#if ALG_DEBUG
+		printf("%02d %08x %08x %08x %08x %08x %08x %08x %08x\n",j,A,B,C,D,E,F,G,H);
+#endif
+	}
+
+	for(j =16; j < 64; j++)
+	{
+		SS1 = ROTL((ROTL(A,12) + E + ROTL(T[j],j)), 7);
+		SS2 = SS1 ^ ROTL(A,12);
+		TT1 = FF1(A,B,C) + D + SS2 + W1[j];
+		TT2 = GG1(E,F,G) + H + SS1 + W[j];
+		D = C;
+		C = ROTL(B,9);
+		B = A;
+		A = TT1;
+		H = G;
+		G = ROTL(F,19);
+		F = E;
+		E = P0(TT2);
+#if ALG_DEBUG
+		printf("%02d %08x %08x %08x %08x %08x %08x %08x %08x\n",j,A,B,C,D,E,F,G,H);
+		printf("%02d %08x %08x %08x %08x %08x %08x %08x %08x\n",j,A,B,C,D,E,F,G,H);
+#endif
+	}
+
+	ctx->state[0] ^= A;
+	ctx->state[1] ^= B;
+	ctx->state[2] ^= C;
+	ctx->state[3] ^= D;
+	ctx->state[4] ^= E;
+	ctx->state[5] ^= F;
+	ctx->state[6] ^= G;
+	ctx->state[7] ^= H;
+#if ALG_DEBUG
+	printf("   %08x %08x %08x %08x %08x %08x %08x %08x\n",ctx->state[0],ctx->state[1],ctx->state[2],
+			ctx->state[3],ctx->state[4],ctx->state[5],ctx->state[6],ctx->state[7]);
+#endif
+}
+
+/*
+ * SM3 process buffer
+ */
+int sm3_update(sm3_ctx *ctx, const u8 *input, u32 ilen)
+{
+	u32 left;
+	int fill;
+
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+	if( ilen <= 0 )
+		return -1;
+
+	left = ctx->total[0] & 0x3F;
+	fill = 64 - left;
+
+	ctx->total[0] += ilen;
+	ctx->total[0] &= 0xFFFFFFFF;
+
+	if( ctx->total[0] < (u32) ilen )
+		ctx->total[1]++;
+
+	if( left && ilen >= fill )
+	{
+		memcpy( (void *) (ctx->buffer + left),
+				(void *) input, fill );
+		sm3_process( ctx, ctx->buffer );
+		input += fill;
+		ilen  -= fill;
+		left = 0;
+	}
+
+	while( ilen >= 64 )
+	{
+		sm3_process( ctx, (u8*)input );
+		input += 64;
+		ilen  -= 64;
+	}
+
+	if( ilen > 0 )
+	{
+		memcpy( (void *) (ctx->buffer + left),
+				(void *) input, ilen );
+	}
+	return 0;
+}
+
+static u8 sm3_padding[64] =
+{
+	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*
+ * SM3 final digest
+ */
+int sm3_finish(sm3_ctx *ctx, u8 *output)
+{
+	u32 last, padn;
+	u32 high, low;
+	u8 msglen[8];
+
+	high = ( ctx->total[0] >> 29 )
+		| ( ctx->total[1] <<  3 );
+	low  = ( ctx->total[0] <<  3 );
+
+	PUT_ULONG_BE( high, msglen, 0 );
+	PUT_ULONG_BE( low,  msglen, 4 );
+
+	last = ctx->total[0] & 0x3F;
+	padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
+
+	sm3_update(ctx, (const u8 *)sm3_padding, padn );
+	sm3_update(ctx, msglen, 8 );
+
+	PUT_ULONG_BE( ctx->state[0], output,  0 );
+	PUT_ULONG_BE( ctx->state[1], output,  4 );
+	PUT_ULONG_BE( ctx->state[2], output,  8 );
+	PUT_ULONG_BE( ctx->state[3], output, 12 );
+	PUT_ULONG_BE( ctx->state[4], output, 16 );
+	PUT_ULONG_BE( ctx->state[5], output, 20 );
+	PUT_ULONG_BE( ctx->state[6], output, 24 );
+	PUT_ULONG_BE( ctx->state[7], output, 28 );
+
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+	return 0;
+}
+
+int sm3_finup(sm3_ctx *ctx, const u8 *data,
+		u32 len, u8 *out)
+{
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+
+	sm3_init(ctx);
+	sm3_update(ctx, data, len);
+	return sm3_finish(ctx, out);
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/sm4.c b/src/libstrongswan/plugins/gmalg/gmalg/sm4.c
new file mode 100644
index 000000000..1a16b95e5
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/sm4.c
@@ -0,0 +1,297 @@
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "debug.h"
+#include "sm4.h"
+
+/*
+ * 32-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_ULONG_BE
+#define GET_ULONG_BE(n,b,i)                      \
+{                                                \
+	(n) =     ( (u32) (b)[(i)    ] << 24 )   \
+		| ( (u32) (b)[(i) + 1] << 16 )   \
+		| ( (u32) (b)[(i) + 2] <<  8 )   \
+		| ( (u32) (b)[(i) + 3]       );  \
+}
+#endif
+
+#ifndef PUT_ULONG_BE
+#define PUT_ULONG_BE(n,b,i)                   \
+{                                             \
+	(b)[(i)    ] = (u8) ( (n) >> 24 );    \
+	(b)[(i) + 1] = (u8) ( (n) >> 16 );    \
+	(b)[(i) + 2] = (u8) ( (n) >>  8 );    \
+	(b)[(i) + 3] = (u8) ( (n)       );    \
+}
+#endif
+
+/*
+ *rotate shift left marco definition
+ *
+ */
+#define SHL(x,n) (((x) & 0xFFFFFFFF) << n)
+#define ROTL(x,n) (SHL((x),n) | ((x) >> (32 - n)))
+
+#define SWAP(a,b) { u32 t = a; a = b; b = t;}
+
+/*
+ * Expanded SM4 S-boxes
+ * Sbox table: 8bits input convert to 8 bits output*/
+
+static const u8 SboxTable[16][16] =
+{
+	{0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05},
+	{0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99},
+	{0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62},
+	{0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6},
+	{0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8},
+	{0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35},
+	{0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87},
+	{0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e},
+	{0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1},
+	{0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3},
+	{0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f},
+	{0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51},
+	{0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8},
+	{0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0},
+	{0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84},
+	{0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48}
+};
+
+/* System parameter */
+static const u32 FK[4] = {0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc};
+
+/* fixed parameter */
+static const u32 CK[32] =
+{
+	0x00070e15,0x1c232a31,0x383f464d,0x545b6269,
+	0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,
+	0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,
+	0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,
+	0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,
+	0x30373e45,0x4c535a61,0x686f767d,0x848b9299,
+	0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,
+	0x10171e25,0x2c333a41,0x484f565d,0x646b7279
+};
+
+/*
+ * private function:
+ * look up in SboxTable and get the related value.
+ * args:    [in] inch: 0x00~0xFF (8 bits unsigned value).
+ */
+static u8 sm4Sbox(u8 inch)
+{
+	u8 *pTable = (u8 *)SboxTable;
+	u8 retVal = (u8)(pTable[inch]);
+	return retVal;
+}
+
+/*
+ * private F(Lt) function:
+ * "T algorithm" == "L algorithm" + "t algorithm".
+ * args:    [in] a: a is a 32 bits unsigned value;
+ * return: c: c is calculated with line algorithm "L" and nonline algorithm "t"
+ */
+static u32 sm4Lt(u32 ka)
+{
+	u32 bb = 0;
+	u32 c = 0;
+	u8 a[4];
+	u8 b[4];
+
+	PUT_ULONG_BE(ka,a,0);
+	b[0] = sm4Sbox(a[0]);
+	b[1] = sm4Sbox(a[1]);
+	b[2] = sm4Sbox(a[2]);
+	b[3] = sm4Sbox(a[3]);
+	GET_ULONG_BE(bb,b,0);
+	c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24));
+	return c;
+}
+
+/*
+ * private F function:
+ * Calculating and getting encryption/decryption contents.
+ * args:    [in] x0: original contents;
+ * args:    [in] x1: original contents;
+ * args:    [in] x2: original contents;
+ * args:    [in] x3: original contents;
+ * args:    [in] rk: encryption/decryption key;
+ * return the contents of encryption/decryption contents.
+ */
+static u32 sm4F(u32 x0, u32 x1, u32 x2, u32 x3, u32 rk)
+{
+	return (x0^sm4Lt(x1^x2^x3^rk));
+}
+
+
+/* private function:
+ * Calculating round encryption key.
+ * args:    [in] a: a is a 32 bits unsigned value;
+ * return: sk[i]: i{0,1,2,3,...31}.
+ */
+static u32 sm4CalciRK(u32 ka)
+{
+	u32 bb = 0;
+	u32 rk = 0;
+	u8 a[4];
+	u8 b[4];
+	PUT_ULONG_BE(ka,a,0);
+	b[0] = sm4Sbox(a[0]);
+	b[1] = sm4Sbox(a[1]);
+	b[2] = sm4Sbox(a[2]);
+	b[3] = sm4Sbox(a[3]);
+	GET_ULONG_BE(bb,b,0);
+	rk = bb^(ROTL(bb, 13))^(ROTL(bb, 23));
+	return rk;
+}
+
+static void sm4_setkey( u32 SK[32], u8 key[16] )
+{
+	u32 MK[4];
+	u32 k[36];
+	u32 i = 0;
+
+	GET_ULONG_BE( MK[0], key, 0 );
+	GET_ULONG_BE( MK[1], key, 4 );
+	GET_ULONG_BE( MK[2], key, 8 );
+	GET_ULONG_BE( MK[3], key, 12 );
+	k[0] = MK[0]^FK[0];
+	k[1] = MK[1]^FK[1];
+	k[2] = MK[2]^FK[2];
+	k[3] = MK[3]^FK[3];
+	for(; i<32; i++)
+	{
+		k[i+4] = k[i] ^ (sm4CalciRK(k[i+1]^k[i+2]^k[i+3]^CK[i]));
+		SK[i] = k[i+4];
+	}
+}
+
+/*
+ * SM4 standard one round processing
+ *
+ */
+static void sm4_one_round( u32 sk[32],
+		u8 input[16],
+		u8 output[16] )
+{
+	u32 i = 0;
+	u32 ulbuf[36];
+
+	memset(ulbuf, 0, sizeof(ulbuf));
+	GET_ULONG_BE( ulbuf[0], input, 0 );
+	GET_ULONG_BE( ulbuf[1], input, 4 );
+	GET_ULONG_BE( ulbuf[2], input, 8 );
+	GET_ULONG_BE( ulbuf[3], input, 12 );
+	while(i<32) {
+		ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);
+		#if ALG_DEBUG
+			printf("rk(%02d) = 0x%08x,  X(%02d) = 0x%08x \n",i,sk[i], i, ulbuf[i+4] );
+		#endif
+		i++;
+	}
+	PUT_ULONG_BE(ulbuf[35],output,0);
+	PUT_ULONG_BE(ulbuf[34],output,4);
+	PUT_ULONG_BE(ulbuf[33],output,8);
+	PUT_ULONG_BE(ulbuf[32],output,12);
+}
+
+int sm4_set_key(sm4_ctx *ctx, u8 *key, u32 len)
+{
+	int i;
+
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+	if( len != 16) {
+		printf(" sm4 set key leng  errr \n");
+		return -1;
+	}
+
+	sm4_setkey(ctx->sk_enc, key);
+
+	memcpy(ctx->sk_dec, ctx->sk_enc, 32*4);
+	for(i = 0; i < 16; i ++) {
+		SWAP(ctx->sk_dec[i], ctx->sk_dec[31-i]);
+	}
+
+	return 0;
+}
+
+void sm4_ecb_encrypt(sm4_ctx *ctx, u8 *key, u8 *in, u8 len, u8 *out)
+{
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+	sm4_set_key(ctx, key, 16);
+
+	while(len > 0) {
+		sm4_one_round(ctx->sk_enc, in, out);
+		in  += 16;
+		out += 16;
+		len -= 16;
+	}
+}
+
+void sm4_ecb_decrypt(sm4_ctx *ctx, u8 *key, u8 *in, u8 len, u8 *out)
+{
+
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+	while( len > 0 ) {
+		sm4_one_round( ctx->sk_dec, in, out);
+		in  += 16;
+		out += 16;
+		len -= 16;
+	}
+}
+
+void sm4_cbc_encrypt(sm4_ctx *ctx, u8 *key, u8 *iv, u8 *in, u8 len, u8 *out)
+{
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+	int i;
+
+	sm4_set_key(ctx, key, 16);
+
+	while(len > 0)
+	{
+		for(i = 0; i < 16; i++)
+			out[i] = (u8)(in[i] ^ iv[i]);
+		sm4_one_round(ctx->sk_enc, out, out);
+		memcpy(iv, out, 16);
+		in  += 16;
+		out += 16;
+		len -= 16;
+	}
+}
+
+void sm4_cbc_decrypt(sm4_ctx *ctx, u8 *key, u8 *iv, u8 *in, u8 len, u8 *out)
+{
+#if DEBUG
+	printf(" function: %s ,  line= %d \n", __FUNCTION__, __LINE__);
+#endif
+	u8 temp[16];
+	int i;
+
+	sm4_set_key(ctx, key, 16);
+
+	while(len > 0)
+	{
+		memcpy(temp, in, 16 );
+		sm4_one_round(ctx->sk_dec, in, out);
+		for(i = 0; i < 16; i++)
+			out[i] = (u8)(out[i] ^ iv[i] );
+		memcpy(iv, temp, 16);
+		in  += 16;
+		out += 16;
+		len -= 16;
+	}
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/utils/key_exchange.c b/src/libstrongswan/plugins/gmalg/gmalg/utils/key_exchange.c
new file mode 100644
index 000000000..3a090725e
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/utils/key_exchange.c
@@ -0,0 +1,99 @@
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+
+#include "sm2.h"
+#include "debug.h"
+
+u8 rA[ECC_NUMBITS] = {
+	0xD4,0xDE,0x15,0x47,0x4D,0xB7,0x4D,0x06,0x49,0x1C,0x44,0x0D,0x30,0x5E,0x01,0x24,
+	0x00,0x99,0x0F,0x3E,0x39,0x0C,0x7E,0x87,0x15,0x3C,0x12,0xDB,0x2E,0xA6,0x0B,0xB3
+};
+
+u8 rB[ECC_NUMBITS]= {
+	0x7E,0x07,0x12,0x48,0x14,0xB3,0x09,0x48,0x91,0x25,0xEA,0xED,0x10,0x11,0x13,0x16,
+	0x4E,0xBF,0x0F,0x34,0x58,0xC5,0xBD,0x88,0x33,0x5C,0x1F,0x9D,0x59,0x62,0x43,0xD6};
+
+ecc_point pubkeyA = {
+	.x = {	0x16,0x0E,0x12,0x89,0x7D,0xF4,0xED,0xB6,0x1D,0xD8,0x12,0xFE,0xB9,0x67,0x48,0xFB,
+		0xD3,0xCC,0xF4,0xFF,0xE2,0x6A,0xA6,0xF6,0xDB,0x95,0x40,0xAF,0x49,0xC9,0x42,0x32},
+	.y = {	0x4A,0x7D,0xAD,0x08,0xBB,0x9A,0x45,0x95,0x31,0x69,0x4B,0xEB,0x20,0xAA,0x48,0x9D,
+		0x66,0x49,0x97,0x5E,0x1B,0xFC,0xF8,0xC4,0x74,0x1B,0x78,0xB4,0xB2,0x23,0x00,0x7F},
+};
+
+u8 prikeyA[ECC_NUMBITS] = {
+	0x81,0xEB,0x26,0xE9,0x41,0xBB,0x5A,0xF1,0x6D,0xF1,0x16,0x49,0x5F,0x90,0x69,0x52,
+	0x72,0xAE,0x2C,0xD6,0x3D,0x6C,0x4A,0xE1,0x67,0x84,0x18,0xBE,0x48,0x23,0x00,0x29
+};
+
+ecc_point pubkeyB = {
+	.x = {0x6A,0xE8,0x48,0xC5,0x7C,0x53,0xC7,0xB1,0xB5,0xFA,0x99,0xEB,0x22,0x86,0xAF,0x07,
+		0x8B,0xA6,0x4C,0x64,0x59,0x1B,0x8B,0x56,0x6F,0x73,0x57,0xD5,0x76,0xF1,0x6D,0xFB},
+	.y = {0xEE,0x48,0x9D,0x77,0x16,0x21,0xA2,0x7B,0x36,0xC5,0xC7,0x99,0x20,0x62,0xE9,0xCD,
+		0x09,0xA9,0x26,0x43,0x86,0xF3,0xFB,0xEA,0x54,0xDF,0xF6,0x93,0x05,0x62,0x1C,0x4D},
+
+};
+
+u8 prikeyB[ECC_NUMBITS] = {
+	0x78,0x51,0x29,0x91,0x7D,0x45,0xA9,0xEA,0x54,0x37,0xA5,0x93,0x56,0xB8,0x23,0x38,
+	0xEA,0xAD,0xDA,0x6C,0xEB,0x19,0x90,0x88,0xF1,0x4A,0xE1,0x0D,0xEF,0xA2,0x29,0xB5};
+
+u8 IDa[16] = {
+	0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38
+};
+
+u8 IDb[16] = {
+	0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38
+};
+
+ecc_point RA;
+ecc_point RB;
+ecc_point V;
+
+u8 K[64];
+u32 klen = 16;
+
+u8 ZA[32];
+u8 ZB[32];
+u8 SB[32];
+u8 SA[32];
+
+int main()
+{
+	int rc;
+
+	printf("ecc test \n");
+
+	sm3_z(IDa, 16, &pubkeyA, ZA);
+	sm3_z(IDb, 16, &pubkeyB, ZB);
+
+	//a
+	rc = ECC_KeyEx_Init_I(rA, &RA);
+	if (rc)
+		printf(" key ex err\n");
+	else
+		printf(" key ex ok\n");
+	///b
+	rc = ECC_KeyEx_Re_I(rB, prikeyB, &RA, &pubkeyA, ZA, ZB, K, klen, &RB, &V, SB);
+	if (rc)
+		printf(" key ex err\n");
+	else
+		printf(" key ex ok\n");
+	//a
+	rc = ECC_KeyEx_Init_II(rA, prikeyA, &RA, &RB, &pubkeyB, ZA, ZB, SB, K, klen, SA);
+	if (rc)
+		printf(" key ex err\n");
+	else
+		printf(" key ex ok\n");
+	//bb
+	rc = ECC_KeyEx_Re_II(&V, &RA, &RB, ZA, ZB, SA);
+	if (rc)
+		printf(" key ex err\n");
+	else
+		printf(" key ex ok\n");
+
+	return 0;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/utils/key_gen.c b/src/libstrongswan/plugins/gmalg/gmalg/utils/key_gen.c
new file mode 100644
index 000000000..9f8b9f142
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/utils/key_gen.c
@@ -0,0 +1,27 @@
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdlib.h>
+
+#include "sm2.h"
+#include "debug.h"
+
+int main(int argc, char **argv)
+{
+	u8 pri[ECC_NUMWORD];
+	ecc_point pub[1];
+
+	int i = 1;
+	while(i--){
+		speed_test("aa", 2);
+		sm2_make_prikey(pri);
+		sm2_make_pubkey(pri, pub);
+	}
+
+	printHex("private", pri, 32);
+	printHex("public_x",pub->x, 32);
+	printHex("public_y",pub->y, 32);
+
+	return 0;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/utils/shared_key.c b/src/libstrongswan/plugins/gmalg/gmalg/utils/shared_key.c
new file mode 100644
index 000000000..22964a349
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/utils/shared_key.c
@@ -0,0 +1,69 @@
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdlib.h>
+
+#include "sm2.h"
+#include "debug.h"
+
+u8 selfPriKey[ECC_NUMWORD];
+u8 selfTempPriKey[ECC_NUMWORD];
+ecc_point selfPubKey[1];
+ecc_point selfTempPubKey[1];
+
+u8 otherPriKey[ECC_NUMWORD];
+u8 otherTempPriKey[ECC_NUMWORD];
+ecc_point otherPubKey[1];
+ecc_point otherTempPubKey[1];
+
+ecc_point selfPoint[1];
+ecc_point otherPoint[1];
+
+u8 selfId[16] = {
+	0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38
+};
+u8 otherId[16] = {
+	0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38
+};
+u8 selfIdLen = 16;
+u8 otherIdLen = 16;
+
+u8 ZA[ECC_NUMWORD];
+u8 ZB[ECC_NUMWORD];
+
+u8 selfKey[16];
+u8 otherKey[16];
+u32 selfKeyLen = 16;
+u32 otherKeyLen = 16;
+
+int main(int argc, char **argv)
+{
+
+	sm2_make_keypair(selfPriKey, selfPubKey);
+	sm2_make_keypair(selfTempPriKey, selfTempPubKey);
+	sm2_make_keypair(otherPriKey, otherPubKey);
+	sm2_make_keypair(otherTempPriKey, otherTempPubKey);
+
+
+	sm2_shared_point(selfPriKey, selfTempPriKey, selfTempPubKey, otherPubKey, otherTempPubKey, selfPoint);
+	printHex("selfkey x", (u8*)selfPoint, ECC_NUMWORD*2);
+
+	sm2_shared_point(otherPriKey, otherTempPriKey, otherTempPubKey, selfPubKey, selfTempPubKey, otherPoint);
+	printHex("otherkey x", (u8*)otherPoint, ECC_NUMWORD*2);
+
+	sm3_z(selfId, selfIdLen, selfPubKey, ZA);
+	sm3_z(otherId, otherIdLen, otherPubKey, ZB);
+
+	sm2_shared_key(selfPoint, ZA, ZB, selfKeyLen, selfKey);
+	sm2_shared_key(otherPoint, ZA, ZB, otherKeyLen, otherKey);
+
+	sm2_point_mult(otherPubKey, selfPriKey, selfPoint); /* U=[x2_]RB */
+	printHex("selfkey x", (u8*)selfPoint, ECC_NUMWORD*2);
+
+	sm2_point_mult(selfPubKey, otherPriKey, otherPoint); /* U=[x2_]RB */
+	printHex("otherkey x", (u8*)otherPoint, ECC_NUMWORD*2);
+
+
+	return 0;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg/utils/sm2.c b/src/libstrongswan/plugins/gmalg/gmalg/utils/sm2.c
new file mode 100644
index 000000000..9d1cb079d
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg/utils/sm2.c
@@ -0,0 +1,69 @@
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdlib.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "sm2.h"
+#include "debug.h"
+
+u8 _random[ECC_NUMWORD] = {
+	0x6F, 0xF9, 0xB2, 0x1F, 0xAE, 0xBA, 0x0D, 0x26, 0x27, 0xB7, 0x72, 0xDD, 0x25, 0xD9, 0x76, 0xC1,
+	0x3F, 0x66, 0x17, 0x48, 0x93, 0x4E, 0xF9, 0x94, 0x5C, 0x17, 0x5C, 0x38, 0x99, 0x8D, 0xB2, 0x6C};
+
+ecc_point pub = {
+	.x = {0x09,0xF9,0xDF,0x31,0x1E,0x54,0x21,0xA1,0x50,0xDD,0x7D,0x16,0x1E,0x4B,0xC5,0xC6,
+		0x72,0x17,0x9F,0xAD,0x18,0x33,0xFC,0x07,0x6B,0xB0,0x8F,0xF3,0x56,0xF3,0x50,0x20},
+
+	.y = {0xCC,0xEA,0x49,0x0C,0xE2,0x67,0x75,0xA5,0x2D,0xC6,0xEA,0x71,0x8C,0xC1,0xAA,0x60,
+		0x0A,0xED,0x05,0xFB,0xF3,0x5E,0x08,0x4A,0x66,0x32,0xF6,0x07,0x2D,0xA9,0xAD,0x13}};
+
+u8 pri[ECC_NUMWORD] = {
+	0x39,0x45,0x20,0x8F,0x7B,0x21,0x44,0xB1,0x3F,0x36,0xE3,0x8A,0xC6,0xD3,0x9F,0x95,
+	0x88,0x93,0x93,0x69,0x28,0x60,0xB5,0x1A,0x42,0xFB,0x81,0xEF,0x4D,0xF7,0xC5,0xB8};
+
+u8 hash[ECC_NUMWORD] = {
+	0x95, 0x8E, 0x72, 0xE6, 0x3C, 0x1B, 0x65, 0xD3, 0x25, 0xAC, 0xF7, 0xF6, 0x50, 0xAF, 0xBA, 0x75,
+	0x32, 0x5E, 0x22, 0x47, 0x58, 0xB0, 0x7C, 0x10, 0x66, 0xBB, 0xC1, 0x5A, 0xC5, 0x46, 0x89, 0xED};
+
+u8 C[ECC_NUMWORD*5];
+u8 M[ECC_NUMWORD*2] = {
+	0x65, 0x6E, 0x63, 0x72,  0x79, 0x70, 0x74, 0x69,  0x6F, 0x6E, 0x20, 0x73,  0x74, 0x61, 0x6E, 0x64,
+	0x61, 0x72, 0x64};
+
+int main(int argc, char **argv)
+{
+	u8 r[ECC_NUMWORD];
+	u8 s[ECC_NUMWORD];
+	int ret = -1;
+	int Clen;
+	int Mlen;
+	int i = 1;
+
+	sm2_make_prikey(pri);
+	sm2_make_pubkey(pri, &pub);
+
+	sm2_sign(r, s, pri, hash);
+	printHex("r", r, 32);
+	printHex("s", s, 32);
+	ret = sm2_verify(&pub, hash, r, s);
+	if (ret)
+		printf("verify err ret = %d\n", ret);
+	else
+		printf("verify ok\n");
+
+	sm2_encrypt(&pub, M, 19, C, &Clen);
+	printHex("C", C, Clen);
+	memset(M, 0, 64);
+	ret = sm2_decrypt(pri, C, Clen, M, &Mlen);
+	if(ret)
+		printf(" decrypt err \n");
+	else
+		printHex("M", M, Mlen);
+
+	return 0;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_crypter.c b/src/libstrongswan/plugins/gmalg/gmalg_crypter.c
new file mode 100644
index 000000000..27d2bf230
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_crypter.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2008 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include "gmalg_crypter.h"
+
+#include <gmalg.h>
+
+typedef struct private_gmalg_crypter_t private_gmalg_crypter_t;
+
+/**
+ * Private data of gmalg_crypter_t
+ */
+struct private_gmalg_crypter_t {
+
+	/**
+	 * Public part of this class.
+	 */
+	gmalg_crypter_t public;
+
+	/*
+	 * the key
+	 */
+	chunk_t	key;
+
+	/*
+	 * the cipher to use
+	 */
+	encryption_algorithm_t algo;
+
+	/*
+	 * the cipher ddevice handle
+	 */
+	void *hDeviceHandle;
+};
+
+/**
+ * Do the actual en/decryption in an EVP context
+ */
+static bool crypt(private_gmalg_crypter_t *this, chunk_t data, chunk_t iv,
+				  chunk_t *dst, int enc)
+{
+	bool success = TRUE;
+	u_int alg_mode;
+	u_char *out;
+	u_int len;
+	int rc;
+
+	switch (this->algo)
+	{
+		case ENCR_SM1_ECB:
+			alg_mode = GMALG_SM1_ECB;
+			break;
+		case ENCR_SM1_CBC:
+			alg_mode = GMALG_SM1_CBC;
+			break;
+		case ENCR_SM4_ECB:
+			alg_mode = GMALG_SM4_CBC;
+			break;
+		case ENCR_SM4_CBC:
+			alg_mode = GMALG_SM4_CBC;
+			break;
+		default:
+		{
+			/* algo unavailable invalid */
+			return FALSE;
+		}
+	}
+
+	out = data.ptr;
+	if (dst)
+	{
+		*dst = chunk_alloc(data.len);
+		out = dst->ptr;
+	}
+
+	if (enc)
+		rc = GMALG_Encrypt(this->hDeviceHandle, this->key.ptr, alg_mode, iv.ptr, data.ptr, data.len, out, &len);
+	else
+		rc = GMALG_Decrypt(this->hDeviceHandle, this->key.ptr, alg_mode, iv.ptr, data.ptr, data.len, out, &len);
+	if(rc)
+		success = FALSE;
+
+	return success;
+}
+
+METHOD(crypter_t, decrypt, bool,
+	private_gmalg_crypter_t *this, chunk_t data, chunk_t iv, chunk_t *dst)
+{
+	return crypt(this, data, iv, dst, 0);
+}
+
+METHOD(crypter_t, encrypt, bool,
+	private_gmalg_crypter_t *this, chunk_t data, chunk_t iv, chunk_t *dst)
+{
+	return crypt(this, data, iv, dst, 1);
+}
+
+METHOD(crypter_t, get_block_size, size_t,
+	private_gmalg_crypter_t *this)
+{
+	return 16;
+}
+
+METHOD(crypter_t, get_iv_size, size_t,
+	private_gmalg_crypter_t *this)
+{
+	return 16;
+}
+
+METHOD(crypter_t, get_key_size, size_t,
+	private_gmalg_crypter_t *this)
+{
+	return this->key.len;
+}
+
+METHOD(crypter_t, set_key, bool,
+	private_gmalg_crypter_t *this, chunk_t key)
+{
+	memcpy(this->key.ptr, key.ptr, min(key.len, this->key.len));
+	return TRUE;
+}
+
+METHOD(crypter_t, destroy, void,
+	private_gmalg_crypter_t *this)
+{
+	GMALG_CloseDevice(this->hDeviceHandle);
+	chunk_clear(&this->key);
+	free(this);
+}
+
+/*
+ * Described in header
+ */
+gmalg_crypter_t *gmalg_crypter_create(encryption_algorithm_t algo,
+												  size_t key_size)
+{
+	private_gmalg_crypter_t *this;
+
+	INIT(this,
+		.public = {
+			.crypter = {
+				.encrypt = _encrypt,
+				.decrypt = _decrypt,
+				.get_block_size = _get_block_size,
+				.get_iv_size = _get_iv_size,
+				.get_key_size = _get_key_size,
+				.set_key = _set_key,
+				.destroy = _destroy,
+			},
+		},
+	);
+
+	this->algo = algo;
+	this->key = chunk_alloc(key_size);
+	GMALG_OpenDevice(&this->hDeviceHandle);
+
+	return &this->public;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_crypter.h b/src/libstrongswan/plugins/gmalg/gmalg_crypter.h
new file mode 100644
index 000000000..a5b0e9e55
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_crypter.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2008 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/**
+ * @defgroup gmalg_crypter gmalg_crypter
+ * @{ @ingroup gmalg_p
+ */
+
+#ifndef GMALG_CRYPTER_H_
+#define GMALG_CRYPTER_H_
+
+typedef struct gmalg_crypter_t gmalg_crypter_t;
+
+#include <crypto/crypters/crypter.h>
+
+/**
+ * Implementation of crypters using OpenSSL.
+ */
+struct gmalg_crypter_t {
+
+	/**
+	 * Implements crypter_t interface.
+	 */
+	crypter_t crypter;
+};
+
+/**
+ * Constructor to create gmalg_crypter_t.
+ *
+ * @param algo			algorithm to implement
+ * @param key_size		key size in bytes
+ * @return				gmalg_crypter_t, NULL if not supported
+ */
+gmalg_crypter_t *gmalg_crypter_create(encryption_algorithm_t algo,
+												  size_t key_size);
+
+#endif /** GMALG_CRYPTER_H_ @}*/
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_ec_diffie_hellman.c b/src/libstrongswan/plugins/gmalg/gmalg_ec_diffie_hellman.c
new file mode 100644
index 000000000..bb2363162
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_ec_diffie_hellman.c
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2008-2013 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+
+#include <gmalg.h>
+
+#include "gmalg_ec_diffie_hellman.h"
+
+#include <utils/debug.h>
+
+typedef struct private_gmalg_ec_diffie_hellman_t private_gmalg_ec_diffie_hellman_t;
+
+/**
+ * Private data of an gmalg_ec_diffie_hellman_t object.
+ */
+struct private_gmalg_ec_diffie_hellman_t {
+	/**
+	 * Public gmalg_ec_diffie_hellman_t interface.
+	 */
+	gmalg_ec_diffie_hellman_t public;
+
+	/**
+	 * Diffie Hellman group number.
+	 */
+	diffie_hellman_group_t group;
+
+	/**
+	 * Shared secret
+	 */
+	chunk_t shared_secret;
+
+	/**
+	 * the cipher device handle
+	 */
+	void *hDeviceHandle;
+
+	ECCrefPublicKey pubKey[1];
+	ECCrefPrivateKey priKey[1];
+	ECCrefPublicKey otherPubKey[1];
+
+	/**
+	 * True if shared secret is computed
+	 */
+	bool computed;
+};
+
+/**
+ * Compute the shared secret.
+ *
+ * We cannot use the function ECDH_compute_key() because that returns only the
+ * x coordinate of the shared secret point (which is defined, for instance, in
+ * 'NIST SP 800-56A').
+ * However, we need both coordinates as RFC 4753 says: "The Diffie-Hellman
+ *   public value is obtained by concatenating the x and y values. The format
+ *   of the Diffie-Hellman shared secret value is the same as that of the
+ *   Diffie-Hellman public value."
+ */
+static bool compute_shared_key(private_gmalg_ec_diffie_hellman_t *this,
+							   chunk_t *shared_secret)
+{
+	ECCrefPublicKey P[1];
+	bool ret = TRUE;
+
+	*shared_secret = chunk_alloc(ECCref_MAX_LEN*2);
+	GMALG_pointMul_ECC(this->hDeviceHandle, this->otherPubKey, this->priKey, P);
+	memcpy(shared_secret->ptr, P->x, ECCref_MAX_LEN);
+	memcpy(shared_secret->ptr + ECCref_MAX_LEN, P->y, ECCref_MAX_LEN);
+
+	return ret;
+}
+
+METHOD(diffie_hellman_t, set_other_public_value, bool,
+	private_gmalg_ec_diffie_hellman_t *this, chunk_t value)
+{
+	chunk_clear(&this->shared_secret);
+
+	memcpy(this->otherPubKey->x, value.ptr, ECCref_MAX_LEN);
+	memcpy(this->otherPubKey->y, value.ptr + ECCref_MAX_LEN, ECCref_MAX_LEN);
+
+	if (!compute_shared_key(this, &this->shared_secret)) {
+		DBG1(DBG_LIB, "ECDH shared secret computation failed");
+		return FALSE;
+	}
+
+	this->computed = TRUE;
+	return TRUE;
+}
+
+METHOD(diffie_hellman_t, get_my_public_value, bool,
+	private_gmalg_ec_diffie_hellman_t *this,chunk_t *value)
+{
+	*value  = chunk_alloc(ECCref_MAX_LEN*2);
+	memcpy(value->ptr, this->pubKey->x, ECCref_MAX_LEN);
+	memcpy(value->ptr + ECCref_MAX_LEN, this->pubKey->y, ECCref_MAX_LEN);
+
+	return TRUE;
+}
+
+METHOD(diffie_hellman_t, set_private_value, bool,
+	private_gmalg_ec_diffie_hellman_t *this, chunk_t value)
+{
+	bool ret = FALSE;
+	if (value.len != ECCref_MAX_LEN)
+		DBG1(DBG_LIB, "SM2 set private value failed");
+
+	memcpy(this->priKey->K, value.ptr, ECCref_MAX_LEN);
+
+	return ret;
+}
+
+METHOD(diffie_hellman_t, get_shared_secret, bool,
+	private_gmalg_ec_diffie_hellman_t *this, chunk_t *secret)
+{
+	if (!this->computed)
+	{
+		return FALSE;
+	}
+	*secret = chunk_clone(this->shared_secret);
+	return TRUE;
+}
+
+METHOD(diffie_hellman_t, get_dh_group, diffie_hellman_group_t,
+	private_gmalg_ec_diffie_hellman_t *this)
+{
+	return this->group;
+}
+
+METHOD(diffie_hellman_t, destroy, void,
+	private_gmalg_ec_diffie_hellman_t *this)
+{
+	GMALG_CloseDevice(this->hDeviceHandle);
+	chunk_clear(&this->shared_secret);
+	free(this);
+}
+
+
+/*
+ * Described in header.
+ */
+gmalg_ec_diffie_hellman_t *gmalg_ec_diffie_hellman_create(diffie_hellman_group_t group)
+{
+	private_gmalg_ec_diffie_hellman_t *this;
+
+	INIT(this,
+		.public = {
+			.dh = {
+				.get_shared_secret = _get_shared_secret,
+				.set_other_public_value = _set_other_public_value,
+				.get_my_public_value = _get_my_public_value,
+				.set_private_value = _set_private_value,
+				.get_dh_group = _get_dh_group,
+				.destroy = _destroy,
+			},
+		},
+		.group = group,
+	);
+
+	if (group != CURVE_SM2)
+	{
+		free(this);
+		return NULL;
+
+	}
+
+	GMALG_OpenDevice(&this->hDeviceHandle);
+	ECCrefPublicKey pubKey[1];
+	ECCrefPrivateKey priKey[1];
+	ECCrefPublicKey otherPubKey[1];
+
+	GMALG_GenerateKeyPair_ECC(this->hDeviceHandle, this->pubKey, this->priKey);
+
+	return &this->public;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_ec_diffie_hellman.h b/src/libstrongswan/plugins/gmalg/gmalg_ec_diffie_hellman.h
new file mode 100644
index 000000000..fc62e367a
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_ec_diffie_hellman.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2008 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/**
+ * @defgroup gmalg_ec_diffie_hellman gmalg_ec_diffie_hellman
+ * @{ @ingroup gmalg_p
+ */
+
+#ifndef GMALG_EC_DIFFIE_HELLMAN_H_
+#define GMALG_EC_DIFFIE_HELLMAN_H_
+
+typedef struct gmalg_ec_diffie_hellman_t gmalg_ec_diffie_hellman_t;
+
+#include <library.h>
+
+/**
+ * Implementation of the EC Diffie-Hellman algorithm using OpenSSL.
+ */
+struct gmalg_ec_diffie_hellman_t {
+
+	/**
+	 * Implements diffie_hellman_t interface.
+	 */
+	diffie_hellman_t dh;
+};
+
+/**
+ * Creates a new gmalg_ec_diffie_hellman_t object.
+ *
+ * @param group			EC Diffie Hellman group number to use
+ * @return				gmalg_ec_diffie_hellman_t object, NULL if not supported
+ */
+gmalg_ec_diffie_hellman_t *gmalg_ec_diffie_hellman_create(diffie_hellman_group_t group);
+
+#endif /** GMALG_EC_DIFFIE_HELLMAN_H_ @}*/
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_ec_private_key.c b/src/libstrongswan/plugins/gmalg/gmalg_ec_private_key.c
new file mode 100644
index 000000000..87b1dc77e
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_ec_private_key.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2008-2016 Tobias Brunner
+ * Copyright (C) 2009 Martin Willi
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include "gmalg_ec_private_key.h"
+#include "gmalg_ec_public_key.h"
+#include "gmalg_util.h"
+
+#include <utils/debug.h>
+
+#include <gmalg.h>
+
+typedef struct private_gmalg_ec_private_key_t private_gmalg_ec_private_key_t;
+
+/**
+ * Private data of a gmalg_ec_private_key_t object.
+ */
+struct private_gmalg_ec_private_key_t {
+	/**
+	 * Public interface for this signer.
+	 */
+	gmalg_ec_private_key_t public;
+
+	/**
+	 * TRUE if the key is from an OpenSSL ENGINE and might not be readable
+	 */
+	bool engine;
+
+	/**
+	 *  key type
+	 */
+	key_type_t type;
+
+	/**
+	 * the cipher device handle
+	 */
+	void *hDeviceHandle;
+
+	ECCrefPublicKey pubkey[1];
+	ECCrefPrivateKey prikey[1];
+
+	/**
+	 * reference count
+	 */
+	refcount_t ref;
+};
+
+/* from ec public key */
+bool gmalg_ec_fingerprint(ECCrefPublicKey *pubkey, cred_encoding_type_t type, chunk_t *fp);
+
+/**
+ * Build a signature as in RFC 4754
+ */
+static bool build_signature(private_gmalg_ec_private_key_t *this,
+							chunk_t hash, chunk_t *signature)
+{
+	bool built = TRUE;
+
+	*signature  = chunk_alloc(sizeof(ECCSignature));
+
+	GMALG_ExternalSign_ECC(this->hDeviceHandle, this->prikey, hash.ptr, hash.len,
+				(ECCSignature *)(signature->ptr));
+
+	return built;
+}
+
+/**
+ * Build a RFC 4754 signature for a specified curve and hash algorithm
+ */
+static bool build_curve_signature(private_gmalg_ec_private_key_t *this,
+								signature_scheme_t scheme, int nid_hash,
+								int nid_curve, chunk_t data, chunk_t *signature)
+{
+	bool built = FALSE;
+	chunk_t hash = chunk_empty;
+
+	if (HASH_SM3 == nid_hash)
+	{
+		hasher_t *h;
+
+		h = lib->crypto->create_hasher(lib->crypto, HASH_SM3);
+		if (h == NULL)
+		{
+			built = FALSE;
+			goto err;
+		}
+
+		built = h->allocate_hash(h, data, &hash);
+		if (built == FALSE)
+			goto err;
+	}
+
+	if (hash.ptr)
+	{
+		built = build_signature(this, hash, signature);
+		chunk_free(&hash);
+		built = TRUE;
+	}
+err:
+	return built;
+}
+
+METHOD(private_key_t, sign, bool,
+	private_gmalg_ec_private_key_t *this, signature_scheme_t scheme,
+	void *params, chunk_t data, chunk_t *signature)
+{
+	switch (scheme)
+	{
+		case SIGN_SM2_WITH_SM3:
+			return build_curve_signature(this, scheme, HASH_SM3, KEY_SM2, data, signature);
+		default:
+			DBG1(DBG_LIB, "signature scheme %N not supported",
+				 signature_scheme_names, scheme);
+			return FALSE;
+	}
+}
+
+METHOD(private_key_t, decrypt, bool,
+	private_gmalg_ec_private_key_t *this, encryption_scheme_t scheme,
+	chunk_t crypto, chunk_t *plain)
+{
+	DBG1(DBG_LIB, "EC private key decryption not implemented");
+	ECCCipher *ipher = (ECCCipher *)crypto.ptr;
+	int len;
+
+	*plain  = chunk_alloc(ipher->L);
+	GMALG_ExternalDecrypt_ECC(this->hDeviceHandle, this->prikey, ipher, plain->ptr, &len);
+
+	return TRUE;
+}
+
+METHOD(private_key_t, get_keysize, int,
+	private_gmalg_ec_private_key_t *this)
+{
+	return sizeof(ECCrefPrivateKey);
+}
+
+METHOD(private_key_t, get_type, key_type_t,
+	private_gmalg_ec_private_key_t *this)
+{
+	return this->type;
+}
+
+METHOD(private_key_t, get_public_key, public_key_t*,
+	private_gmalg_ec_private_key_t *this)
+{
+	public_key_t *public;
+	chunk_t key;
+
+	gmalg_i2d_ec_pubkey(this->pubkey, &key);
+
+	public = lib->creds->create(lib->creds, CRED_PUBLIC_KEY, this->type,
+								BUILD_BLOB_ASN1_DER, key, BUILD_END);
+	free(key.ptr);
+	return public;
+}
+
+METHOD(private_key_t, get_fingerprint, bool,
+	private_gmalg_ec_private_key_t *this, cred_encoding_type_t type,
+	chunk_t *fingerprint)
+{
+	return gmalg_ec_fingerprint(this->pubkey, type, fingerprint);
+}
+
+METHOD(private_key_t, get_encoding, bool,
+	private_gmalg_ec_private_key_t *this, cred_encoding_type_t type,
+	chunk_t *encoding)
+{
+
+	if (this->engine)
+	{
+		return FALSE;
+	}
+
+	switch (type)
+	{
+		case PRIVKEY_ASN1_DER:
+		case PRIVKEY_PEM:
+		{
+			bool success = TRUE;
+
+			gmalg_i2d_EC_prikey(this->prikey, this->pubkey, encoding);
+			if (type == PRIVKEY_PEM)
+			{
+				chunk_t asn1_encoding = *encoding;
+
+				success = lib->encoding->encode(lib->encoding, PRIVKEY_PEM,
+								NULL, encoding, CRED_PART_ECDSA_PRIV_ASN1_DER,
+								asn1_encoding, CRED_PART_END);
+				chunk_clear(&asn1_encoding);
+			}
+			return success;
+		}
+		default:
+			return FALSE;
+	}
+}
+
+METHOD(private_key_t, get_ref, private_key_t*,
+	private_gmalg_ec_private_key_t *this)
+{
+	ref_get(&this->ref);
+	return &this->public.key;
+}
+
+METHOD(private_key_t, destroy, void,
+	private_gmalg_ec_private_key_t *this)
+{
+	if (ref_put(&this->ref))
+	{
+		GMALG_CloseDevice(this->hDeviceHandle);
+		free(this);
+	}
+}
+
+/**
+ * Internal generic constructor
+ */
+static private_gmalg_ec_private_key_t *create_empty(void)
+{
+	private_gmalg_ec_private_key_t *this;
+
+	INIT(this,
+		.public = {
+			.key = {
+				.get_type = _get_type,
+				.sign = _sign,
+				.decrypt = _decrypt,
+				.get_keysize = _get_keysize,
+				.get_public_key = _get_public_key,
+				.equals = private_key_equals,
+				.belongs_to = private_key_belongs_to,
+				.get_fingerprint = _get_fingerprint,
+				.has_fingerprint = private_key_has_fingerprint,
+				.get_encoding = _get_encoding,
+				.get_ref = _get_ref,
+				.destroy = _destroy,
+			},
+		},
+		.ref = 1,
+	);
+
+	GMALG_OpenDevice(&this->hDeviceHandle);
+
+	return this;
+}
+
+/*
+ * See header.
+ */
+gmalg_ec_private_key_t *gmalg_ec_private_key_gen(key_type_t type,
+													 va_list args)
+{
+	private_gmalg_ec_private_key_t *this;
+	u_int key_size = 0;
+
+	while (TRUE)
+	{
+		switch (va_arg(args, builder_part_t))
+		{
+			case BUILD_KEY_SIZE:
+				key_size = va_arg(args, u_int);
+				continue;
+			case BUILD_END:
+				break;
+			default:
+				return NULL;
+		}
+		break;
+	}
+	if (!key_size)
+	{
+		return NULL;
+	}
+	this = create_empty();
+	switch (type)
+	{
+		case KEY_SM2:{
+			GMALG_GenerateKeyPair_ECC(this->hDeviceHandle, this->pubkey, this->prikey);
+		}break;
+		default:{
+			DBG1(DBG_LIB, "EC private type %d key size %d not supported", type, key_size);
+			destroy(this);
+			return NULL;
+		}
+	}
+	this->type = type;
+	return &this->public;
+}
+
+/**
+ * See header.
+ */
+gmalg_ec_private_key_t *gmalg_ec_private_key_load(key_type_t type,
+													  va_list args)
+{
+	private_gmalg_ec_private_key_t *this;
+	chunk_t par = chunk_empty, key = chunk_empty;
+	while (TRUE)
+	{
+		switch (va_arg(args, builder_part_t))
+		{
+			case BUILD_BLOB_ALGID_PARAMS:
+				par = va_arg(args, chunk_t);
+				continue;
+			case BUILD_BLOB_ASN1_DER:
+				key = va_arg(args, chunk_t);
+				continue;
+			case BUILD_END:
+				break;
+			default:
+				return NULL;
+		}
+		break;
+	}
+
+	this = create_empty();
+
+	if (par.ptr)
+	{
+		gmalg_d2i_ec_prikey(this->prikey, this->pubkey, key);
+	}
+	else if (key.ptr)
+	{
+		gmalg_d2i_ec_prikey(this->prikey, this->pubkey, key);
+	} else
+		goto error;
+
+	this->type = type;
+	return &this->public;
+
+error:
+	destroy(this);
+	return NULL;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_ec_private_key.h b/src/libstrongswan/plugins/gmalg/gmalg_ec_private_key.h
new file mode 100644
index 000000000..9a17d0162
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_ec_private_key.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2008-2016 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/**
+ * @defgroup gmalg_ec_private_key gmalg_ec_private_key
+ * @{ @ingroup gmalg_p
+ */
+
+#ifndef GMALG_EC_PRIVATE_KEY_H_
+#define GMALG_EC_PRIVATE_KEY_H_
+
+#include <openssl/evp.h>
+
+#include <credentials/builder.h>
+#include <credentials/keys/private_key.h>
+
+typedef struct gmalg_ec_private_key_t gmalg_ec_private_key_t;
+
+/**
+ * private_key_t implementation of ECDSA using OpenSSL.
+ */
+struct gmalg_ec_private_key_t {
+
+	/**
+	 * Implements private_key_t interface
+	 */
+	private_key_t key;
+};
+
+/**
+ * Generate a ECDSA private key using OpenSSL.
+ *
+ * Accepts the BUILD_KEY_SIZE argument.
+ *
+ * @param type		type of the key, must be KEY_ECDSA
+ * @param args		builder_part_t argument list
+ * @return 			generated key, NULL on failure
+ */
+gmalg_ec_private_key_t *gmalg_ec_private_key_gen(key_type_t type,
+													 va_list args);
+
+/**
+ * Load a ECDSA private key using OpenSSL.
+ *
+ * Accepts a BUILD_BLOB_ASN1_DER argument.
+ *
+ * @param type		type of the key, must be KEY_ECDSA
+ * @param args		builder_part_t argument list
+ * @return 			loaded key, NULL on failure
+ */
+gmalg_ec_private_key_t *gmalg_ec_private_key_load(key_type_t type,
+													  va_list args);
+
+/**
+ * Wrap an EVP_PKEY object of type EVP_PKEY_EC
+ *
+ * @param key		EVP_PKEY_EC key object (adopted)
+ * @param engine	whether the key was loaded via an engine
+ * @return 			loaded key, NULL on failure
+ */
+private_key_t *gmalg_ec_private_key_create(EVP_PKEY *key, bool engine);
+
+#endif /** GMALG_EC_PRIVATE_KEY_H_ @}*/
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_ec_public_key.c b/src/libstrongswan/plugins/gmalg/gmalg_ec_public_key.c
new file mode 100644
index 000000000..6edd0b846
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_ec_public_key.c
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2009 Martin Willi
+ * Copyright (C) 2008 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include "gmalg_ec_public_key.h"
+#include "gmalg_util.h"
+
+#include <utils/debug.h>
+
+#include <gmalg.h>
+
+typedef struct private_gmalg_ec_public_key_t private_gmalg_ec_public_key_t;
+
+/**
+ * Private data structure with signing context.
+ */
+struct private_gmalg_ec_public_key_t {
+	/**
+	 * Public interface for this signer.
+	 */
+	gmalg_ec_public_key_t public;
+
+	/**
+	 *  key type
+	 */
+	key_type_t type;
+
+	/**
+	 * the cipher device handle
+	 */
+	void *hDeviceHandle;
+
+	ECCrefPublicKey pubkey[1];
+
+	/**
+	 * reference counter
+	 */
+	refcount_t ref;
+};
+
+/**
+ * Verification of a signature as in RFC 4754
+ */
+static bool verify_signature(private_gmalg_ec_public_key_t *this,
+							 chunk_t hash, chunk_t signature)
+{
+	int rc;
+
+	rc = GMALG_ExternalVerify_ECC(this->hDeviceHandle, this->pubkey,
+				hash.ptr, hash.len, (ECCSignature *)signature.ptr);
+	if (rc)
+		return FALSE;
+
+	return TRUE;
+}
+
+/**
+ * Verify a RFC 4754 signature for a specified curve and hash algorithm
+ */
+static bool verify_curve_signature(private_gmalg_ec_public_key_t *this,
+								signature_scheme_t scheme, int nid_hash,
+								int nid_curve, chunk_t data, chunk_t signature)
+{
+	bool valid = FALSE;
+	chunk_t hash = chunk_empty;
+
+	if (HASH_SM3 == nid_hash)
+	{
+		hasher_t *h;
+
+		h = lib->crypto->create_hasher(lib->crypto, HASH_SM3);
+		if (h == NULL)
+		{
+			valid = FALSE;
+			goto err;
+		}
+
+		valid = h->allocate_hash(h, data, &hash);
+		if (valid == FALSE)
+			goto err;
+	}
+
+	if (hash.ptr)
+	{
+		valid = verify_signature(this, hash, signature);
+		chunk_free(&hash);
+		valid = TRUE;
+	}
+err:
+	return valid;
+}
+
+METHOD(public_key_t, get_type, key_type_t,
+	private_gmalg_ec_public_key_t *this)
+{
+	return this->type;
+}
+
+METHOD(public_key_t, verify, bool,
+	private_gmalg_ec_public_key_t *this, signature_scheme_t scheme,
+	void *params, chunk_t data, chunk_t signature)
+{
+	switch (scheme)
+	{
+		case SIGN_SM2_WITH_SM3:
+			return verify_curve_signature(this, scheme, HASH_SM3, KEY_SM2, data, signature);
+		default:
+			DBG1(DBG_LIB, "signature scheme %N not supported in EC",
+				 signature_scheme_names, scheme);
+			return FALSE;
+	}
+}
+
+METHOD(public_key_t, encrypt, bool,
+	private_gmalg_ec_public_key_t *this, encryption_scheme_t scheme,
+	chunk_t crypto, chunk_t *plain)
+{
+	DBG1(DBG_LIB, "EC public key encryption not implemented");
+
+	*plain  = chunk_alloc(sizeof(ECCCipher));
+	GMALG_ExternalEncrytp_ECC(this->hDeviceHandle, this->pubkey,
+			crypto.ptr, crypto.len, (ECCCipher*)plain->ptr);
+
+	return TRUE;
+}
+
+METHOD(public_key_t, get_keysize, int,
+	private_gmalg_ec_public_key_t *this)
+{
+	return sizeof(ECCrefPublicKey);
+}
+
+/**
+ * Calculate fingerprint from a EC_KEY, also used in ec private key.
+ */
+bool gmalg_ec_fingerprint(ECCrefPublicKey *pubkey, cred_encoding_type_t type, chunk_t *fp)
+{
+	hasher_t *hasher;
+	chunk_t key;
+	u_char *p;
+
+	if (lib->encoding->get_cache(lib->encoding, type, pubkey, fp))
+	{
+		return TRUE;
+	}
+	switch (type)
+	{
+		case KEYID_PUBKEY_SHA1:
+			if(gmalg_i2d_ec_pubkey(pubkey, &key) == FALSE)
+				return FALSE;
+			break;
+		case KEYID_PUBKEY_INFO_SHA1:
+
+			if(gmalg_i2d_ec_pubkey(pubkey, &key) == FALSE)
+				return FALSE;
+
+			break;
+		default:
+			return FALSE;
+	}
+	hasher = lib->crypto->create_hasher(lib->crypto, HASH_SHA1);
+	if (!hasher || !hasher->allocate_hash(hasher, key, fp))
+	{
+		DBG1(DBG_LIB, "SHA1 hash algorithm not supported, fingerprinting failed");
+		DESTROY_IF(hasher);
+		free(key.ptr);
+		return FALSE;
+	}
+
+	hasher->destroy(hasher);
+	free(key.ptr);
+
+	memset(fp->ptr, 0x88, fp->len);
+
+	lib->encoding->cache(lib->encoding, type, pubkey, *fp);
+	return TRUE;
+}
+
+METHOD(public_key_t, get_fingerprint, bool,
+	private_gmalg_ec_public_key_t *this, cred_encoding_type_t type,
+	chunk_t *fingerprint)
+{
+	return gmalg_ec_fingerprint(this->pubkey, type, fingerprint);
+}
+
+METHOD(public_key_t, get_encoding, bool,
+	private_gmalg_ec_public_key_t *this, cred_encoding_type_t type,
+	chunk_t *encoding)
+{
+	bool success = TRUE;
+
+	gmalg_i2d_ec_pubkey(this->pubkey, encoding);
+
+	if (type != PUBKEY_SPKI_ASN1_DER)
+	{
+		chunk_t asn1_encoding = *encoding;
+
+		success = lib->encoding->encode(lib->encoding, type,
+						NULL, encoding, CRED_PART_ECDSA_PUB_ASN1_DER,
+						asn1_encoding, CRED_PART_END);
+		chunk_clear(&asn1_encoding);
+	}
+	return success;
+}
+
+METHOD(public_key_t, get_ref, public_key_t*,
+	private_gmalg_ec_public_key_t *this)
+{
+	ref_get(&this->ref);
+	return &this->public.key;
+}
+
+METHOD(public_key_t, destroy, void,
+	private_gmalg_ec_public_key_t *this)
+{
+	if (ref_put(&this->ref))
+	{
+		GMALG_CloseDevice(this->hDeviceHandle);
+		free(this);
+	}
+}
+
+/**
+ * Generic private constructor
+ */
+static private_gmalg_ec_public_key_t *create_empty()
+{
+	private_gmalg_ec_public_key_t *this;
+
+	INIT(this,
+		.public = {
+			.key = {
+				.get_type = _get_type,
+				.verify = _verify,
+				.encrypt = _encrypt,
+				.get_keysize = _get_keysize,
+				.equals = public_key_equals,
+				.get_fingerprint = _get_fingerprint,
+				.has_fingerprint = public_key_has_fingerprint,
+				.get_encoding = _get_encoding,
+				.get_ref = _get_ref,
+				.destroy = _destroy,
+			},
+		},
+		.ref = 1,
+	);
+
+	GMALG_OpenDevice(&this->hDeviceHandle);
+
+	return this;
+}
+
+/**
+ * See header.
+ */
+gmalg_ec_public_key_t *gmalg_ec_public_key_load(key_type_t type,
+													va_list args)
+{
+	private_gmalg_ec_public_key_t *this;
+	chunk_t blob = chunk_empty;
+
+	if (type != KEY_SM2)
+	{
+		return NULL;
+	}
+
+	while (TRUE)
+	{
+		switch (va_arg(args, builder_part_t))
+		{
+			case BUILD_BLOB_ASN1_DER:
+				blob = va_arg(args, chunk_t);
+				continue;
+			case BUILD_END:
+				break;
+			default:
+				return NULL;
+		}
+		break;
+	}
+
+	if (!blob.len)
+	{
+		return NULL;
+	}
+
+	this = create_empty();
+
+	gmalg_d2i_ec_pubkey(this->pubkey, blob);
+
+	this->type =type;
+
+	return &this->public;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_ec_public_key.h b/src/libstrongswan/plugins/gmalg/gmalg_ec_public_key.h
new file mode 100644
index 000000000..45467a0a3
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_ec_public_key.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2008 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/**
+ * @defgroup gmalg_ec_public_key gmalg_ec_public_key
+ * @{ @ingroup gmalg_p
+ */
+
+#ifndef GMALG_EC_PUBLIC_KEY_H_
+#define GMALG_EC_PUBLIC_KEY_H_
+
+typedef struct gmalg_ec_public_key_t gmalg_ec_public_key_t;
+
+#include <credentials/builder.h>
+#include <credentials/keys/public_key.h>
+
+/**
+ * public_key_t implementation of ECDSA using OpenSSL.
+ */
+struct gmalg_ec_public_key_t {
+
+	/**
+	 * Implements the public_key_t interface
+	 */
+	public_key_t key;
+};
+
+/**
+ * Load a ECDSA public key using OpenSSL.
+ *
+ * Accepts a BUILD_BLOB_ASN1_DER argument.
+ *
+ * @param type		type of the key, must be KEY_ECDSA
+ * @param args		builder_part_t argument list
+ * @return 			loaded key, NULL on failure
+ */
+gmalg_ec_public_key_t *gmalg_ec_public_key_load(key_type_t type,
+													va_list args);
+
+#endif /** GMALG_EC_PUBLIC_KEY_H_ @}*/
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_hasher.c b/src/libstrongswan/plugins/gmalg/gmalg_hasher.c
new file mode 100644
index 000000000..a1ee6e29e
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_hasher.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2008-2017 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include "gmalg_hasher.h"
+
+#include <gmalg.h>
+
+typedef struct private_gmalg_hasher_t private_gmalg_hasher_t;
+
+/**
+ * Private data of gmalg_hasher_t
+ */
+struct private_gmalg_hasher_t {
+
+	/**
+	 * Public part of this class.
+	 */
+	gmalg_hasher_t public;
+
+	/**
+	 * the hasher to use
+	 */
+	hash_algorithm_t algo;
+
+	/*
+	 * the cipher device handle
+	 */
+	void *hDeviceHandle;
+
+};
+
+METHOD(hasher_t, get_hash_size, size_t,
+	private_gmalg_hasher_t *this)
+{
+	return HASH_SIZE_SM3;
+}
+
+METHOD(hasher_t, reset, bool,
+	private_gmalg_hasher_t *this)
+{
+	bool rc = TRUE;
+
+	GMALG_HashInit(this->hDeviceHandle, NULL, NULL, 0);
+
+	return rc;
+}
+
+METHOD(hasher_t, get_hash, bool,
+	private_gmalg_hasher_t *this, chunk_t chunk, uint8_t *hash)
+{
+	GMALG_HashUpdate(this->hDeviceHandle, chunk.ptr, chunk.len);
+
+	if (hash)
+	{
+		u_int len;
+		GMALG_HashFinal(this->hDeviceHandle, hash, &len);
+		GMALG_HashInit(this->hDeviceHandle, NULL, NULL, 0);
+	}
+	return TRUE;
+}
+
+METHOD(hasher_t, allocate_hash, bool,
+	private_gmalg_hasher_t *this, chunk_t chunk, chunk_t *hash)
+{
+	if (hash)
+	{
+		*hash = chunk_alloc(get_hash_size(this));
+		return get_hash(this, chunk, hash->ptr);
+	}
+	return get_hash(this, chunk, NULL);
+}
+
+METHOD(hasher_t, destroy, void,
+	private_gmalg_hasher_t *this)
+{
+	GMALG_CloseDevice(this->hDeviceHandle);
+	free(this);
+}
+
+/*
+ * Described in header
+ */
+gmalg_hasher_t *gmalg_hasher_create(hash_algorithm_t algo)
+{
+	private_gmalg_hasher_t *this;
+
+	INIT(this,
+		.public = {
+			.hasher = {
+				.get_hash = _get_hash,
+				.allocate_hash = _allocate_hash,
+				.get_hash_size = _get_hash_size,
+				.reset = _reset,
+				.destroy = _destroy,
+			},
+		},
+	);
+
+	this->algo = algo;
+	GMALG_OpenDevice(&this->hDeviceHandle);
+	GMALG_HashInit(this->hDeviceHandle, NULL, NULL, 0);
+
+	return &this->public;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_hasher.h b/src/libstrongswan/plugins/gmalg/gmalg_hasher.h
new file mode 100644
index 000000000..b62531e3e
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_hasher.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2008-2017 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/**
+ * @defgroup gmalg_hasher gmalg_hasher
+ * @{ @ingroup gmalg_p
+ */
+
+#ifndef GMALG_HASHER_H_
+#define GMALG_HASHER_H_
+
+typedef struct gmalg_hasher_t gmalg_hasher_t;
+
+#include <crypto/hashers/hasher.h>
+
+#include <openssl/evp.h>
+
+/**
+ * Implementation of hashers using OpenSSL.
+ */
+struct gmalg_hasher_t {
+
+	/**
+	 * Implements hasher_t interface.
+	 */
+	hasher_t hasher;
+};
+
+/**
+ * Determine EVP_MD for the given hash algorithm
+ *
+ * @param hash			hash algorithm
+ * @return				EVP_MD or NULL if not found/supported
+ */
+const EVP_MD *gmalg_get_md(hash_algorithm_t hash);
+
+/**
+ * Constructor to create gmalg_hasher_t.
+ *
+ * @param algo			algorithm
+ * @return				gmalg_hasher_t, NULL if not supported
+ */
+gmalg_hasher_t *gmalg_hasher_create(hash_algorithm_t algo);
+
+#endif /** GMALG_HASHER_H_ @}*/
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_plugin.c b/src/libstrongswan/plugins/gmalg/gmalg_plugin.c
new file mode 100644
index 000000000..5a56a7920
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_plugin.c
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2008-2016 Tobias Brunner
+ * Copyright (C) 2008 Martin Willi
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <library.h>
+#include <utils/debug.h>
+#include <threading/thread.h>
+#include <threading/mutex.h>
+#include <threading/thread_value.h>
+
+#include <gmalg.h>
+
+#include "gmalg_plugin.h"
+#include "gmalg_crypter.h"
+#include "gmalg_hasher.h"
+#include "gmalg_ec_private_key.h"
+#include "gmalg_ec_public_key.h"
+#include "gmalg_rng.h"
+#include "gmalg_ec_diffie_hellman.h"
+
+typedef struct private_gmalg_plugin_t private_gmalg_plugin_t;
+
+/**
+ * private data of gmalg_plugin
+ */
+struct private_gmalg_plugin_t {
+
+	/**
+	 * public functions
+	 */
+	gmalg_plugin_t public;
+};
+
+METHOD(plugin_t, get_name, char*,
+	private_gmalg_plugin_t *this)
+{
+	return "gmalg";
+}
+
+METHOD(plugin_t, get_features, int,
+	private_gmalg_plugin_t *this, plugin_feature_t *features[])
+{
+	static plugin_feature_t f[] = {
+		/* we provide GmSdf threading callbacks */
+		PLUGIN_PROVIDE(CUSTOM, "gmalg-threading"),
+		/* crypters */
+		PLUGIN_REGISTER(CRYPTER, gmalg_crypter_create),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_SM1_ECB, 16),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_SM1_CBC, 16),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_ECB, 16),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_CBC, 16),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_NULL, 0),
+		/* hashers */
+		PLUGIN_REGISTER(HASHER, gmalg_hasher_create),
+			PLUGIN_PROVIDE(HASHER, HASH_SM3),
+		/* EC DH groups */
+		PLUGIN_REGISTER(DH, gmalg_ec_diffie_hellman_create),
+					PLUGIN_PROVIDE(DH, CURVE_SM2),
+		/* EC private/public key loading */
+		PLUGIN_REGISTER(PRIVKEY, gmalg_ec_private_key_load, TRUE),
+			PLUGIN_PROVIDE(PRIVKEY, KEY_SM2),
+		PLUGIN_REGISTER(PRIVKEY_GEN, gmalg_ec_private_key_gen, FALSE),
+			PLUGIN_PROVIDE(PRIVKEY_GEN, KEY_SM2),
+		PLUGIN_REGISTER(PUBKEY, gmalg_ec_public_key_load, TRUE),
+			PLUGIN_PROVIDE(PUBKEY, KEY_SM2),
+		/* signature encryption schemes */
+		PLUGIN_PROVIDE(PRIVKEY_SIGN, SIGN_SM2_WITH_SM3),
+		PLUGIN_PROVIDE(PUBKEY_VERIFY, SIGN_SM2_WITH_SM3),
+
+		PLUGIN_REGISTER(RNG, gmalg_rng_create),
+			PLUGIN_PROVIDE(RNG, RNG_STRONG),
+			PLUGIN_PROVIDE(RNG, RNG_WEAK),
+	};
+	*features = f;
+	return countof(f);
+}
+
+METHOD(plugin_t, destroy, void,
+	private_gmalg_plugin_t *this)
+{
+	free(this);
+}
+
+/*
+ * see header file
+ */
+plugin_t *gmalg_plugin_create()
+{
+	private_gmalg_plugin_t *this;
+
+	INIT(this,
+		.public = {
+			.plugin = {
+				.get_name = _get_name,
+				.get_features = _get_features,
+				.destroy = _destroy,
+			},
+		},
+	);
+
+	return &this->public.plugin;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_plugin.h b/src/libstrongswan/plugins/gmalg/gmalg_plugin.h
new file mode 100644
index 000000000..7bdf22961
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_plugin.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2008 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/**
+ * @defgroup gmalg_p gmalg
+ * @ingroup plugins
+ *
+ * @defgroup gmalg_plugin gmalg_plugin
+ * @{ @ingroup gmalg_p
+ */
+
+#ifndef GMALG_PLUGIN_H_
+#define GMALG_PLUGIN_H_
+
+#include <plugins/plugin.h>
+
+typedef struct gmalg_plugin_t gmalg_plugin_t;
+
+/**
+ * Plugin implementing crypto functions via the gmalg library
+ */
+struct gmalg_plugin_t {
+
+	/**
+	 * implements plugin interface
+	 */
+	plugin_t plugin;
+};
+
+#endif /** GMALG_PLUGIN_H_ @}*/
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_rng.c b/src/libstrongswan/plugins/gmalg/gmalg_rng.c
new file mode 100644
index 000000000..270d189ba
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_rng.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2012 Aleksandr Grinberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <library.h>
+#include <utils/debug.h>
+
+#include <gmalg.h>
+
+#include "gmalg_rng.h"
+
+typedef struct private_gmalg_rng_t private_gmalg_rng_t;
+
+/**
+ * Private data of gmalg_rng_t
+ */
+struct private_gmalg_rng_t {
+
+	/**
+	 * Public part of this class.
+	 */
+	gmalg_rng_t public;
+
+	/**
+	 * Quality of randomness
+	 */
+	rng_quality_t quality;
+
+	/*
+	 * the cipher ddevice handle
+	 */
+	void *hDeviceHandle;
+};
+
+METHOD(rng_t, get_bytes, bool,
+	private_gmalg_rng_t *this, size_t bytes, uint8_t *buffer)
+{
+	bool rc = 1;
+
+	GMALG_GenerateRandom(this->hDeviceHandle, bytes, buffer);
+	return rc;
+}
+
+METHOD(rng_t, allocate_bytes, bool,
+	private_gmalg_rng_t *this, size_t bytes, chunk_t *chunk)
+{
+	*chunk = chunk_alloc(bytes);
+	if (!get_bytes(this, chunk->len, chunk->ptr))
+	{
+		chunk_free(chunk);
+		return FALSE;
+	}
+	return TRUE;
+}
+
+METHOD(rng_t, destroy, void,
+	private_gmalg_rng_t *this)
+{
+	GMALG_CloseDevice(this->hDeviceHandle);
+	free(this);
+}
+
+/*
+ * Described in header.
+ */
+gmalg_rng_t *gmalg_rng_create(rng_quality_t quality)
+{
+	private_gmalg_rng_t *this;
+
+	INIT(this,
+		.public = {
+			.rng = {
+				.get_bytes = _get_bytes,
+				.allocate_bytes = _allocate_bytes,
+				.destroy = _destroy,
+			},
+		},
+		.quality = quality,
+	);
+
+	GMALG_OpenDevice(&this->hDeviceHandle);
+
+	return &this->public;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_rng.h b/src/libstrongswan/plugins/gmalg/gmalg_rng.h
new file mode 100644
index 000000000..97fb10e8d
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_rng.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2012 Aleksandr Grinberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/**
+ * @defgroup gmalg_rng gmalg_rng
+ * @{ @ingroup gmalg_p
+ */
+
+#ifndef GMALG_RNG_H_
+#define GMALG_RNG_H_
+
+#include <library.h>
+
+typedef struct gmalg_rng_t gmalg_rng_t;
+
+/**
+ * Implementation of random number using OpenSSL.
+ */
+struct gmalg_rng_t {
+
+	/**
+	 * Implements rng_t interface.
+	 */
+	rng_t rng;
+};
+
+/**
+ * Constructor to create gmalg_rng_t.
+ *
+ * @param quality	quality of randomness
+ * @return			gmalg_rng_t
+ */
+gmalg_rng_t *gmalg_rng_create(rng_quality_t quality);
+
+#endif /** GMALG_RNG_H_ @}*/
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_util.c b/src/libstrongswan/plugins/gmalg/gmalg_util.c
new file mode 100644
index 000000000..67e9a8392
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_util.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2009 Martin Willi
+ * Copyright (C) 2008 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include "gmalg.h"
+
+#include "gmalg_util.h"
+
+#include <utils/debug.h>
+
+#define PRI_TEMPLET_LEN 121
+#define PRI_TEMPLET_PRI_OFFSET 7
+#define PRI_TEMPLET_PUB_OFFSET_X 57
+#define PRI_TEMPLET_PUB_OFFSET_Y 89
+
+#define PUB_TEMPLET_LEN 91
+#define PUB_TEMPLET_PUB_OFFSET_X 27
+#define PUB_TEMPLET_PUB_OFFSET_Y 59
+
+u_char pri_templet[] = {
+	0x30 ,0x77 ,0x02 ,0x01 ,0x01 ,0x04 ,0x20 ,0xff  ,0x0f ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xa0  ,0x0a ,0x06 ,0x08 ,0x2a ,0x81 ,0x1c ,0xcf ,0x55,
+	0x01 ,0x82 ,0x2d ,0xa1 ,0x44 ,0x03 ,0x42 ,0x00  ,0x04 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff
+};
+
+u_char pub_templet[] = {
+	0x30 ,0x59 ,0x30 ,0x13 ,0x06 ,0x07 ,0x2a ,0x86  ,0x48 ,0xce ,0x3d ,0x02 ,0x01 ,0x06 ,0x08 ,0x2a,
+	0x81 ,0x1c ,0xcf ,0x55 ,0x01 ,0x82 ,0x2d ,0x03  ,0x42 ,0x00 ,0x04 ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff,
+	0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff  ,0xff ,0xff ,0xff
+};
+
+/**
+ * Described in header.
+ */
+bool gmalg_d2i_ec_pubkey(ECCrefPublicKey *pubkey, chunk_t data)
+{
+	if(data.len != PUB_TEMPLET_LEN)
+		return FALSE;
+
+	pubkey->bits = ntohl(0x100);
+	memcpy(pubkey->x, data.ptr + PUB_TEMPLET_PUB_OFFSET_X, 32);
+	memcpy(pubkey->y, data.ptr + PUB_TEMPLET_PUB_OFFSET_Y, 32);
+
+	return TRUE;
+}
+
+/**
+ * Described in header.
+ */
+bool gmalg_i2d_ec_pubkey(ECCrefPublicKey *pubkey, chunk_t *data)
+{
+	*data = chunk_alloc(PUB_TEMPLET_LEN);
+
+	memcpy(data->ptr, pub_templet, PUB_TEMPLET_LEN);
+
+	memcpy(data->ptr + PUB_TEMPLET_PUB_OFFSET_X, pubkey->x, 32);
+	memcpy(data->ptr + PUB_TEMPLET_PUB_OFFSET_Y, pubkey->y, 32);
+
+	return TRUE;
+}
+
+/**
+ * Described in header.
+ */
+bool gmalg_d2i_ec_prikey(ECCrefPrivateKey *prikey, ECCrefPublicKey *pubkey, chunk_t data)
+{
+
+	if(data.len != PRI_TEMPLET_LEN)
+		return FALSE;
+
+	prikey->bits = ntohl(0x100);
+	memcpy(prikey->K, data.ptr + PRI_TEMPLET_PRI_OFFSET, 32);
+
+	pubkey->bits = ntohl(0x100);
+	memcpy(pubkey->x, data.ptr + PRI_TEMPLET_PUB_OFFSET_X, 32);
+	memcpy(pubkey->y, data.ptr + PRI_TEMPLET_PUB_OFFSET_Y, 32);
+
+	return TRUE;
+}
+
+/**
+ * Described in header.
+ */
+bool gmalg_i2d_EC_prikey(ECCrefPrivateKey *prikey, ECCrefPublicKey *pubkey,  chunk_t *data)
+{
+
+	*data = chunk_alloc(PRI_TEMPLET_LEN);
+	memcpy(data->ptr, pri_templet, PRI_TEMPLET_LEN);
+
+	memcpy(data->ptr + PRI_TEMPLET_PUB_OFFSET_X, pubkey->x, 32);
+	memcpy(data->ptr + PRI_TEMPLET_PUB_OFFSET_Y, pubkey->y, 32);
+
+	memcpy(data->ptr + PRI_TEMPLET_PRI_OFFSET, prikey->K, 32);
+
+	return TRUE;
+}
diff --git a/src/libstrongswan/plugins/gmalg/gmalg_util.h b/src/libstrongswan/plugins/gmalg/gmalg_util.h
new file mode 100644
index 000000000..b144d1e1e
--- /dev/null
+++ b/src/libstrongswan/plugins/gmalg/gmalg_util.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2008 Tobias Brunner
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/**
+ * @defgroup gmalg_util gmalg_util
+ * @{ @ingroup gmalg_p
+ */
+
+#ifndef GMALG_UTIL_H_
+#define GMALG_UTIL_H_
+
+#include <library.h>
+#include <gmalg.h>
+
+/**
+ * Described in header.
+ */
+bool gmalg_d2i_ec_pubkey(ECCrefPublicKey *pubkey, chunk_t data);
+
+/**
+ * Described in header.
+ */
+bool gmalg_i2d_ec_pubkey(ECCrefPublicKey *pubkey, chunk_t *data);
+
+/**
+ * Described in header.
+ */
+bool gmalg_d2i_ec_prikey(ECCrefPrivateKey *prikey, ECCrefPublicKey *pubkey, chunk_t data);
+
+/**
+ * Described in header.
+ */
+bool gmalg_i2d_EC_prikey(ECCrefPrivateKey *prikey, ECCrefPublicKey *pubkey,  chunk_t *data);
+
+#endif /** GMALG_UTIL_H_ @}*/
diff --git a/src/libstrongswan/plugins/hmac/hmac.c b/src/libstrongswan/plugins/hmac/hmac.c
index 63c294b32..aede093ee 100644
--- a/src/libstrongswan/plugins/hmac/hmac.c
+++ b/src/libstrongswan/plugins/hmac/hmac.c
@@ -155,6 +155,7 @@ static mac_t *hmac_create(hash_algorithm_t hash_algorithm)
 	/* set b, according to hasher */
 	switch (hash_algorithm)
 	{
+		case HASH_SM3:
 		case HASH_SHA1:
 		case HASH_MD5:
 		case HASH_SHA256:
diff --git a/src/libstrongswan/plugins/hmac/hmac_plugin.c b/src/libstrongswan/plugins/hmac/hmac_plugin.c
index 68eb7d91a..e98ffbb32 100644
--- a/src/libstrongswan/plugins/hmac/hmac_plugin.c
+++ b/src/libstrongswan/plugins/hmac/hmac_plugin.c
@@ -42,6 +42,8 @@ METHOD(plugin_t, get_features, int,
 {
 	static plugin_feature_t f[] = {
 		PLUGIN_REGISTER(PRF, hmac_prf_create),
+			PLUGIN_PROVIDE(PRF, PRF_HMAC_SM3),
+				PLUGIN_DEPENDS(HASHER,  HASH_SM3),
 			PLUGIN_PROVIDE(PRF, PRF_HMAC_SHA1),
 				PLUGIN_DEPENDS(HASHER,  HASH_SHA1),
 			PLUGIN_PROVIDE(PRF, PRF_HMAC_MD5),
@@ -53,6 +55,8 @@ METHOD(plugin_t, get_features, int,
 			PLUGIN_PROVIDE(PRF, PRF_HMAC_SHA2_512),
 				PLUGIN_DEPENDS(HASHER,  HASH_SHA512),
 		PLUGIN_REGISTER(SIGNER, hmac_signer_create),
+			PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_SM3),
+				PLUGIN_DEPENDS(HASHER,  HASH_SM3),
 			PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_SHA1_96),
 				PLUGIN_DEPENDS(HASHER,  HASH_SHA1),
 			PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_SHA1_128),
diff --git a/src/libstrongswan/plugins/openssl/openssl_crl.c b/src/libstrongswan/plugins/openssl/openssl_crl.c
index bb5f20dcf..7fba9dad9 100644
--- a/src/libstrongswan/plugins/openssl/openssl_crl.c
+++ b/src/libstrongswan/plugins/openssl/openssl_crl.c
@@ -193,7 +193,7 @@ METHOD(enumerator_t, crl_enumerate, bool,
 				if (ASN1_STRING_type(crlrsn) == V_ASN1_ENUMERATED &&
 					ASN1_STRING_length(crlrsn) == 1)
 				{
-					*reason = *ASN1_STRING_data(crlrsn);
+					*reason = *ASN1_STRING_get0_data(crlrsn);
 				}
 				ASN1_STRING_free(crlrsn);
 			}
diff --git a/src/libstrongswan/plugins/openssl/openssl_crypter.c b/src/libstrongswan/plugins/openssl/openssl_crypter.c
index 74beb762e..8d5d08d97 100644
--- a/src/libstrongswan/plugins/openssl/openssl_crypter.c
+++ b/src/libstrongswan/plugins/openssl/openssl_crypter.c
@@ -187,6 +187,24 @@ openssl_crypter_t *openssl_crypter_create(encryption_algorithm_t algo,
 
 	switch (algo)
 	{
+		case ENCR_SM1_ECB:
+			//this->cipher = EVP_get_cipherbyname("SM1-ECB");
+			this->cipher = EVP_get_cipherbyname("SMS4-ECB");
+			key_size = 16;
+			break;
+		case ENCR_SM1_CBC:
+			//this->cipher = EVP_get_cipherbyname("SM1-CBC");
+			this->cipher = EVP_get_cipherbyname("SMS4-CBC");
+			key_size = 16;
+			break;
+		case ENCR_SM4_ECB:
+			this->cipher = EVP_get_cipherbyname("SMS4-ECB");
+			key_size = 16;
+			break;
+		case ENCR_SM4_CBC:
+			this->cipher = EVP_get_cipherbyname("SMS4-CBC");
+			key_size = 16;
+			break;
 		case ENCR_NULL:
 			this->cipher = EVP_enc_null();
 			key_size = 0;
diff --git a/src/libstrongswan/plugins/openssl/openssl_ec_diffie_hellman.c b/src/libstrongswan/plugins/openssl/openssl_ec_diffie_hellman.c
index 19de540b6..e3b9e7054 100644
--- a/src/libstrongswan/plugins/openssl/openssl_ec_diffie_hellman.c
+++ b/src/libstrongswan/plugins/openssl/openssl_ec_diffie_hellman.c
@@ -615,6 +615,9 @@ openssl_ec_diffie_hellman_t *openssl_ec_diffie_hellman_create(diffie_hellman_gro
 
 	switch (group)
 	{
+		case CURVE_SM2:
+			this->key = EC_KEY_new_by_curve_name(NID_sm2p256v1);
+			break;
 		case ECP_192_BIT:
 			this->key = EC_KEY_new_by_curve_name(NID_X9_62_prime192v1);
 			break;
diff --git a/src/libstrongswan/plugins/openssl/openssl_ec_private_key.c b/src/libstrongswan/plugins/openssl/openssl_ec_private_key.c
index 364190758..f1b37a4ad 100644
--- a/src/libstrongswan/plugins/openssl/openssl_ec_private_key.c
+++ b/src/libstrongswan/plugins/openssl/openssl_ec_private_key.c
@@ -53,6 +53,11 @@ struct private_openssl_ec_private_key_t {
 	 */
 	bool engine;
 
+	/**
+	 *  key type
+	 */
+	key_type_t type;
+
 	/**
 	 * reference count
 	 */
@@ -165,6 +170,9 @@ METHOD(private_key_t, sign, bool,
 			return build_der_signature(this, NID_sha384, data, signature);
 		case SIGN_ECDSA_WITH_SHA512_DER:
 			return build_der_signature(this, NID_sha512, data, signature);
+		case SIGN_SM2_WITH_SM3:
+			return build_curve_signature(this, scheme, NID_sm3,
+										 NID_sm2p256v1, data, signature);
 		case SIGN_ECDSA_256:
 			return build_curve_signature(this, scheme, NID_sha256,
 										 NID_X9_62_prime256v1, data, signature);
@@ -198,7 +206,7 @@ METHOD(private_key_t, get_keysize, int,
 METHOD(private_key_t, get_type, key_type_t,
 	private_openssl_ec_private_key_t *this)
 {
-	return KEY_ECDSA;
+	return this->type;
 }
 
 METHOD(private_key_t, get_public_key, public_key_t*,
@@ -211,8 +219,7 @@ METHOD(private_key_t, get_public_key, public_key_t*,
 	key = chunk_alloc(i2d_EC_PUBKEY(this->ec, NULL));
 	p = key.ptr;
 	i2d_EC_PUBKEY(this->ec, &p);
-
-	public = lib->creds->create(lib->creds, CRED_PUBLIC_KEY, KEY_ECDSA,
+	public = lib->creds->create(lib->creds, CRED_PUBLIC_KEY, this->type,
 								BUILD_BLOB_ASN1_DER, key, BUILD_END);
 	free(key.ptr);
 	return public;
@@ -362,21 +369,34 @@ openssl_ec_private_key_t *openssl_ec_private_key_gen(key_type_t type,
 		return NULL;
 	}
 	this = create_empty();
-	switch (key_size)
+	switch (type)
 	{
-		case 256:
-			this->ec = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
-			break;
-		case 384:
-			this->ec = EC_KEY_new_by_curve_name(NID_secp384r1);
-			break;
-		case 521:
-			this->ec = EC_KEY_new_by_curve_name(NID_secp521r1);
-			break;
-		default:
-			DBG1(DBG_LIB, "EC private key size %d not supported", key_size);
+		case KEY_SM2:{
+			this->ec = EC_KEY_new_by_curve_name(NID_sm2p256v1);
+		}break;
+		case KEY_ECDSA:
+		switch (key_size)
+		{
+			case 256:
+				this->ec = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
+				break;
+			case 384:
+				this->ec = EC_KEY_new_by_curve_name(NID_secp384r1);
+				break;
+			case 521:
+				this->ec = EC_KEY_new_by_curve_name(NID_secp521r1);
+				break;
+			default:
+				DBG1(DBG_LIB, "EC private key size %d not supported", key_size);
+				destroy(this);
+				return NULL;
+		}
+		break;
+		default:{
+			DBG1(DBG_LIB, "EC private type %d key size %d not supported", type, key_size);
 			destroy(this);
 			return NULL;
+		}
 	}
 	if (EC_KEY_generate_key(this->ec) != 1)
 	{
@@ -384,6 +404,7 @@ openssl_ec_private_key_t *openssl_ec_private_key_gen(key_type_t type,
 		destroy(this);
 		return NULL;
 	}
+	this->type = type;
 	/* encode as a named curve key (no parameters), uncompressed public key */
 	EC_KEY_set_asn1_flag(this->ec, OPENSSL_EC_NAMED_CURVE);
 	EC_KEY_set_conv_form(this->ec, POINT_CONVERSION_UNCOMPRESSED);
@@ -443,6 +464,7 @@ openssl_ec_private_key_t *openssl_ec_private_key_load(key_type_t type,
 	{
 		goto error;
 	}
+	this->type = type;
 	return &this->public;
 
 error:
diff --git a/src/libstrongswan/plugins/openssl/openssl_ec_public_key.c b/src/libstrongswan/plugins/openssl/openssl_ec_public_key.c
index ba41c508f..ae25cd456 100644
--- a/src/libstrongswan/plugins/openssl/openssl_ec_public_key.c
+++ b/src/libstrongswan/plugins/openssl/openssl_ec_public_key.c
@@ -47,6 +47,11 @@ struct private_openssl_ec_public_key_t {
 	 */
 	EC_KEY *ec;
 
+	/**
+	 *  key type
+	 */
+	key_type_t type;
+
 	/**
 	 * reference counter
 	 */
@@ -146,7 +151,7 @@ static bool verify_der_signature(private_openssl_ec_public_key_t *this,
 METHOD(public_key_t, get_type, key_type_t,
 	private_openssl_ec_public_key_t *this)
 {
-	return KEY_ECDSA;
+	return this->type;
 }
 
 METHOD(public_key_t, verify, bool,
@@ -165,6 +170,9 @@ METHOD(public_key_t, verify, bool,
 			return verify_der_signature(this, NID_sha512, data, signature);
 		case SIGN_ECDSA_WITH_NULL:
 			return verify_signature(this, data, signature);
+		case SIGN_SM2_WITH_SM3:
+			return verify_curve_signature(this, scheme, NID_sm3,
+										  NID_sm2p256v1, data, signature);
 		case SIGN_ECDSA_256:
 			return verify_curve_signature(this, scheme, NID_sha256,
 										  NID_X9_62_prime256v1, data, signature);
@@ -325,7 +333,7 @@ openssl_ec_public_key_t *openssl_ec_public_key_load(key_type_t type,
 	private_openssl_ec_public_key_t *this;
 	chunk_t blob = chunk_empty;
 
-	if (type != KEY_ECDSA)
+	if (type != KEY_ECDSA && type != KEY_SM2)
 	{
 		return NULL;
 	}
@@ -351,6 +359,7 @@ openssl_ec_public_key_t *openssl_ec_public_key_load(key_type_t type,
 		destroy(this);
 		return NULL;
 	}
+	this->type =type;
 	return &this->public;
 }
 #endif /* OPENSSL_NO_ECDSA */
diff --git a/src/libstrongswan/plugins/openssl/openssl_plugin.c b/src/libstrongswan/plugins/openssl/openssl_plugin.c
index 8b0a7c5c7..93cefea8b 100644
--- a/src/libstrongswan/plugins/openssl/openssl_plugin.c
+++ b/src/libstrongswan/plugins/openssl/openssl_plugin.c
@@ -476,6 +476,10 @@ METHOD(plugin_t, get_features, int,
 		PLUGIN_PROVIDE(CUSTOM, "openssl-threading"),
 		/* crypters */
 		PLUGIN_REGISTER(CRYPTER, openssl_crypter_create),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_SM1_ECB, 16),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_SM1_CBC, 16),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_ECB, 16),
+			PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_CBC, 16),
 #ifndef OPENSSL_NO_AES
 			PLUGIN_PROVIDE(CRYPTER, ENCR_AES_CBC, 16),
 			PLUGIN_PROVIDE(CRYPTER, ENCR_AES_CBC, 24),
@@ -506,6 +510,7 @@ METHOD(plugin_t, get_features, int,
 			PLUGIN_PROVIDE(CRYPTER, ENCR_NULL, 0),
 		/* hashers */
 		PLUGIN_REGISTER(HASHER, openssl_hasher_create),
+			PLUGIN_PROVIDE(HASHER, HASH_SM3),
 #ifndef OPENSSL_NO_MD2
 			PLUGIN_PROVIDE(HASHER, HASH_MD2),
 #endif
@@ -533,6 +538,7 @@ METHOD(plugin_t, get_features, int,
 #endif
 #ifndef OPENSSL_NO_HMAC
 		PLUGIN_REGISTER(PRF, openssl_hmac_prf_create),
+			PLUGIN_PROVIDE(PRF, PRF_HMAC_SM3),
 #ifndef OPENSSL_NO_MD5
 			PLUGIN_PROVIDE(PRF, PRF_HMAC_MD5),
 #endif
@@ -547,6 +553,7 @@ METHOD(plugin_t, get_features, int,
 			PLUGIN_PROVIDE(PRF, PRF_HMAC_SHA2_512),
 #endif
 		PLUGIN_REGISTER(SIGNER, openssl_hmac_signer_create),
+			PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_SM3),
 #ifndef OPENSSL_NO_MD5
 			PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_MD5_96),
 			PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_MD5_128),
@@ -585,6 +592,7 @@ METHOD(plugin_t, get_features, int,
 #ifndef OPENSSL_NO_ECDH
 		/* EC DH groups */
 		PLUGIN_REGISTER(DH, openssl_ec_diffie_hellman_create),
+			PLUGIN_PROVIDE(DH, CURVE_SM2),
 			PLUGIN_PROVIDE(DH, ECP_256_BIT),
 			PLUGIN_PROVIDE(DH, ECP_384_BIT),
 			PLUGIN_PROVIDE(DH, ECP_521_BIT),
@@ -656,6 +664,7 @@ METHOD(plugin_t, get_features, int,
 			PLUGIN_PROVIDE(CERT_DECODE, CERT_X509),
 				PLUGIN_SDEPEND(PUBKEY, KEY_RSA),
 				PLUGIN_SDEPEND(PUBKEY, KEY_ECDSA),
+				PLUGIN_SDEPEND(PUBKEY, KEY_SM2),
 				PLUGIN_SDEPEND(PUBKEY, KEY_DSA),
 		PLUGIN_REGISTER(CERT_DECODE, openssl_crl_load, TRUE),
 			PLUGIN_PROVIDE(CERT_DECODE, CERT_X509_CRL),
@@ -671,11 +680,16 @@ METHOD(plugin_t, get_features, int,
 		/* EC private/public key loading */
 		PLUGIN_REGISTER(PRIVKEY, openssl_ec_private_key_load, TRUE),
 			PLUGIN_PROVIDE(PRIVKEY, KEY_ECDSA),
+			PLUGIN_PROVIDE(PRIVKEY, KEY_SM2),
 		PLUGIN_REGISTER(PRIVKEY_GEN, openssl_ec_private_key_gen, FALSE),
 			PLUGIN_PROVIDE(PRIVKEY_GEN, KEY_ECDSA),
+			PLUGIN_PROVIDE(PRIVKEY_GEN, KEY_SM2),
 		PLUGIN_REGISTER(PUBKEY, openssl_ec_public_key_load, TRUE),
 			PLUGIN_PROVIDE(PUBKEY, KEY_ECDSA),
+			PLUGIN_PROVIDE(PUBKEY, KEY_SM2),
 		/* signature encryption schemes */
+		PLUGIN_PROVIDE(PRIVKEY_SIGN, SIGN_SM2_WITH_SM3),
+		PLUGIN_PROVIDE(PUBKEY_VERIFY, SIGN_SM2_WITH_SM3),
 		PLUGIN_PROVIDE(PRIVKEY_SIGN, SIGN_ECDSA_WITH_NULL),
 		PLUGIN_PROVIDE(PUBKEY_VERIFY, SIGN_ECDSA_WITH_NULL),
 #ifndef OPENSSL_NO_SHA1
diff --git a/src/libstrongswan/plugins/openssl/openssl_util.c b/src/libstrongswan/plugins/openssl/openssl_util.c
index b7f969f73..64782d4a8 100644
--- a/src/libstrongswan/plugins/openssl/openssl_util.c
+++ b/src/libstrongswan/plugins/openssl/openssl_util.c
@@ -168,7 +168,7 @@ chunk_t openssl_asn1_str2chunk(ASN1_STRING *asn1)
 {
 	if (asn1)
 	{
-		return chunk_create(ASN1_STRING_data(asn1), ASN1_STRING_length(asn1));
+		return chunk_create(ASN1_STRING_get0_data(asn1), ASN1_STRING_length(asn1));
 	}
 	return chunk_empty;
 }
diff --git a/src/libstrongswan/plugins/openssl/openssl_x509.c b/src/libstrongswan/plugins/openssl/openssl_x509.c
index fae2d678f..7512ef1bd 100644
--- a/src/libstrongswan/plugins/openssl/openssl_x509.c
+++ b/src/libstrongswan/plugins/openssl/openssl_x509.c
@@ -1129,8 +1129,8 @@ static bool parse_certificate(private_openssl_x509_t *this)
 		return FALSE;
 	}
 
-	this->notBefore = openssl_asn1_to_time(X509_get_notBefore(this->x509));
-	this->notAfter = openssl_asn1_to_time(X509_get_notAfter(this->x509));
+	this->notBefore = openssl_asn1_to_time(X509_getm_notBefore(this->x509));
+	this->notAfter = openssl_asn1_to_time(X509_getm_notAfter(this->x509));
 
 	/* while X509_ALGOR_cmp() is declared in the headers of older OpenSSL
 	 * versions, at least on Ubuntu 14.04 it is not actually defined */
diff --git a/src/libstrongswan/plugins/pem/pem_plugin.c b/src/libstrongswan/plugins/pem/pem_plugin.c
index eb9e420ff..603ec0f35 100644
--- a/src/libstrongswan/plugins/pem/pem_plugin.c
+++ b/src/libstrongswan/plugins/pem/pem_plugin.c
@@ -56,6 +56,10 @@ METHOD(plugin_t, get_features, int,
 			PLUGIN_PROVIDE(PRIVKEY, KEY_ECDSA),
 				PLUGIN_DEPENDS(PRIVKEY, KEY_ECDSA),
 				PLUGIN_SDEPEND(HASHER, HASH_MD5),
+		PLUGIN_REGISTER(PRIVKEY, pem_private_key_load, FALSE),
+			PLUGIN_PROVIDE(PRIVKEY, KEY_SM2),
+				PLUGIN_DEPENDS(PRIVKEY, KEY_SM2),
+				PLUGIN_SDEPEND(HASHER, HASH_SM3),
 		PLUGIN_REGISTER(PRIVKEY, pem_private_key_load, FALSE),
 			PLUGIN_PROVIDE(PRIVKEY, KEY_DSA),
 				PLUGIN_DEPENDS(PRIVKEY, KEY_DSA),
@@ -77,6 +81,9 @@ METHOD(plugin_t, get_features, int,
 		PLUGIN_REGISTER(PUBKEY, pem_public_key_load, FALSE),
 			PLUGIN_PROVIDE(PUBKEY, KEY_ECDSA),
 				PLUGIN_DEPENDS(PUBKEY, KEY_ECDSA),
+		PLUGIN_REGISTER(PUBKEY, pem_public_key_load, FALSE),
+			PLUGIN_PROVIDE(PUBKEY, KEY_SM2),
+				PLUGIN_DEPENDS(PUBKEY, KEY_SM2),
 		PLUGIN_REGISTER(PUBKEY, pem_public_key_load, FALSE),
 			PLUGIN_PROVIDE(PUBKEY, KEY_DSA),
 				PLUGIN_DEPENDS(PUBKEY, KEY_DSA),
diff --git a/src/libstrongswan/plugins/pkcs1/pkcs1_builder.c b/src/libstrongswan/plugins/pkcs1/pkcs1_builder.c
index 967e501d1..08fbac03a 100644
--- a/src/libstrongswan/plugins/pkcs1/pkcs1_builder.c
+++ b/src/libstrongswan/plugins/pkcs1/pkcs1_builder.c
@@ -45,6 +45,7 @@ static public_key_t *parse_public_key(chunk_t blob)
 	int objectID;
 	public_key_t *key = NULL;
 	key_type_t type = KEY_ANY;
+	chunk_t  param = chunk_empty;
 
 	parser = asn1_parser_create(pkinfoObjects, blob);
 
@@ -55,7 +56,7 @@ static public_key_t *parse_public_key(chunk_t blob)
 			case PKINFO_SUBJECT_PUBLIC_KEY_ALGORITHM:
 			{
 				int oid = asn1_parse_algorithmIdentifier(object,
-										parser->get_level(parser)+1, NULL);
+										parser->get_level(parser)+1, &param);
 
 				if (oid == OID_RSA_ENCRYPTION || oid == OID_RSAES_OAEP ||
 					oid == OID_RSASSA_PSS)
@@ -68,9 +69,21 @@ static public_key_t *parse_public_key(chunk_t blob)
 				}
 				else if (oid == OID_EC_PUBLICKEY)
 				{
+					key_type_t type = KEY_ECDSA;
+
+					if(param.len > 2)
+					{
+						int oid_sm2 = asn1_known_oid(chunk_create(param.ptr+2,
+												param.len - 2));
+						if (oid_sm2 == OID_SM2)
+						{
+							type = KEY_SM2;
+						}
+					}
+
 					/* Need the whole subjectPublicKeyInfo for EC public keys */
 					key = lib->creds->create(lib->creds, CRED_PUBLIC_KEY,
-								KEY_ECDSA, BUILD_BLOB_ASN1_DER, blob, BUILD_END);
+								type, BUILD_BLOB_ASN1_DER, blob, BUILD_END);
 					goto end;
 				}
 				else if (oid == OID_BLISS_PUBLICKEY)
@@ -284,6 +297,29 @@ static bool is_ec_private_key(chunk_t blob)
 		   asn1_unwrap(&blob, &data) == ASN1_CONTEXT_C_1;
 }
 
+static key_type_t get_ec_private_key_type(chunk_t blob)
+{
+	chunk_t data;
+	key_type_t type = KEY_ECDSA;
+
+	if(asn1_unwrap(&blob, &blob) == ASN1_SEQUENCE &&
+			asn1_unwrap(&blob, &data) == ASN1_INTEGER &&
+			asn1_unwrap(&blob, &data) == ASN1_OCTET_STRING &&
+			asn1_unwrap(&blob, &data) == ASN1_CONTEXT_C_0)
+	{
+		if(data.len > 2)
+		{
+			int oid_sm2 = asn1_known_oid(chunk_create(data.ptr+2, data.len - 2));
+
+			if (oid_sm2 == OID_SM2)
+			{
+				type = KEY_SM2;
+			}
+		}
+	}
+	return type;
+}
+
 /**
  * Check if the ASN.1 structure looks like a BLISS private key.
  */
@@ -305,7 +341,8 @@ static private_key_t *parse_private_key(chunk_t blob)
 {
 	if (is_ec_private_key(blob))
 	{
-		return lib->creds->create(lib->creds, CRED_PRIVATE_KEY, KEY_ECDSA,
+		key_type_t type = get_ec_private_key_type(blob);
+		return lib->creds->create(lib->creds, CRED_PRIVATE_KEY, type,
 								  BUILD_BLOB_ASN1_DER, blob, BUILD_END);
 	}
 	else if (is_bliss_private_key(blob))
diff --git a/src/pki/Makefile.am b/src/pki/Makefile.am
index 1153794cd..982640fbf 100644
--- a/src/pki/Makefile.am
+++ b/src/pki/Makefile.am
@@ -15,6 +15,7 @@ pki_SOURCES = pki.c pki.h command.c command.h \
 	commands/req.c \
 	commands/self.c \
 	commands/signcrl.c \
+	commands/crypto.c \
 	commands/verify.c
 
 pki_LDADD = \
diff --git a/src/pki/command.h b/src/pki/command.h
index 353f5141c..43dab746a 100644
--- a/src/pki/command.h
+++ b/src/pki/command.h
@@ -24,7 +24,7 @@
 /**
  * Maximum number of commands (+1).
  */
-#define MAX_COMMANDS 14
+#define MAX_COMMANDS 15
 
 /**
  * Maximum number of options in a command (+3)
diff --git a/src/pki/commands/crypto.c b/src/pki/commands/crypto.c
new file mode 100644
index 000000000..59b6df923
--- /dev/null
+++ b/src/pki/commands/crypto.c
@@ -0,0 +1,485 @@
+/*
+ * Copyright (C) 2010 Martin Willi
+ * Copyright (C) 2010 revosec AG
+ *
+ * Copyright (C) 2015-2016 Andreas Steffen
+ * HSR Hochschule fuer Technik Rapperswil
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include "pki.h"
+
+#include <crypto/mac.h>
+#include <crypto/prfs/prf.h>
+
+#include <errno.h>
+
+#define GMSDF_RNG	2
+#define GMSDF_HASH	3
+#define GMSDF_CRYPTER	4
+#define GMSDF_PRF	5
+#define GMSDF_SIGNER	6
+#define GMSDF_DH	7
+#define GMSDF_SM2	8
+
+void print_hex(unsigned char *name, unsigned char *c, int n)
+{
+	int i;
+
+	fprintf(stderr, "\n------------start[%s ,len = %d, start ]", name, n);
+	for(i=0;i<n;i++)
+	{
+		if(i%16==0){
+			fprintf(stderr, "\n%04d:  ", i);
+		}
+		fprintf(stderr, "%02X",c[i]);
+		if(i%4==3)
+			fprintf(stderr, " ");
+
+	}
+	fprintf(stderr, "\n--------------end[%s ,len = %d, start ]\n\n", name, n);
+}
+
+/**
+ * Read input data as chunk
+ *
+ */
+chunk_t read_from_file(char *file)
+{
+	char buf[8096];
+	size_t len, total = 0;
+	FILE *stream;
+
+	stream = fopen(file, "r");
+	if (!stream)
+	{
+		return chunk_empty;
+	}
+
+	while (TRUE)
+	{
+		len = fread(buf + total, 1, sizeof(buf) - total, stream);
+		if (len < (sizeof(buf) - total))
+		{
+			if (ferror(stream))
+			{
+				fclose(stream);
+				return chunk_empty;
+			}
+			if (feof(stream))
+			{
+				fclose(stream);
+				return chunk_clone(chunk_create(buf, total + len));
+			}
+		}
+		total += len;
+		if (total == sizeof(buf))
+		{
+			fprintf(stderr, "buffer too small to read input!\n");
+			fclose(stream);
+			return chunk_empty;
+		}
+	}
+}
+
+/**
+ * Write output data from chunk to stream
+ *
+ */
+bool write_to_file(char *file, chunk_t data)
+{
+	size_t len, total = 0;
+	FILE *stream;
+
+	stream = fopen(file, "r");
+	if (!stream)
+	{
+		return FALSE;
+	}
+
+	set_file_mode(stream, CERT_ASN1_DER);
+	while (total < data.len)
+	{
+		len = fwrite(data.ptr + total, 1, data.len - total, stream);
+		if (len <= 0)
+		{
+			return FALSE;
+		}
+		total += len;
+	}
+	return TRUE;
+}
+
+int gmsdf_crypter_test(chunk_t data)
+{
+	int ret = 0;
+	int key_size = 16;
+	crypter_t *crypter;
+	encryption_algorithm_t alg = ENCR_SM4_CBC;
+	chunk_t response = chunk_empty;
+	chunk_t key = chunk_empty;
+	chunk_t iv = chunk_empty;
+	chunk_t d = chunk_create(data.ptr, data.len&0xfff0);
+
+	crypter = lib->crypto->create_crypter(lib->crypto, alg, key_size);
+	if (!crypter)
+	{
+		fprintf(stderr, "create crypter failed \n");
+		return FALSE;
+	}
+
+	if(crypter->get_block_size(crypter) != key_size)
+	{
+		crypter->destroy(crypter);
+		fprintf(stderr, "get block size failed \n");
+		return FALSE;
+	}
+
+	key = chunk_alloc(key_size);
+	iv = chunk_alloc(key_size);
+	response = chunk_alloc(d.len);
+
+	memset(key.ptr, 0, key.len);
+	memset(iv.ptr, 0x88, iv.len);
+	memset(response.ptr, 0, response.len);
+
+	if(!crypter->set_key(crypter, key))
+	{
+		fprintf(stderr, "failed to set key \n");
+		ret = FALSE;
+	}
+
+	print_hex("in data", d.ptr, d.len);
+
+	if (!crypter->encrypt(crypter, d, iv, &response))
+	{
+		fprintf(stderr, "decryption failed \n");
+		ret = FALSE;
+	}
+
+	print_hex("temp data", response.ptr, response.len);
+
+	if (!crypter->decrypt(crypter, response, iv, &d))
+	{
+		fprintf(stderr, "encryption failed \n");
+		ret = FALSE;
+	}
+
+	print_hex("out data", d.ptr, d.len);
+
+	crypter->destroy(crypter);
+	chunk_free(&response);
+	chunk_free(&key);
+	chunk_free(&iv);
+	return ret;
+}
+
+int gmsdf_hash_test(chunk_t data)
+{
+	int ret = 0;
+	hasher_t *hasher;
+	hash_algorithm_t algo = HASH_SM3;
+	chunk_t response = chunk_empty;
+
+	hasher = lib->crypto->create_hasher(lib->crypto, algo);
+	if (hasher == NULL)
+	{
+		printf(" create hasher err \n");
+		ret = FAILED;
+	}
+
+	if (!hasher->allocate_hash(hasher, data, &response))
+	{
+		printf(" allocate hasher err \n");
+		ret = FAILED;
+	}
+
+	print_hex("in  data", data.ptr, data.len);
+	print_hex("out data", response.ptr, response.len);
+
+	hasher->destroy(hasher);
+	chunk_free(&response);
+
+	return ret;
+}
+
+int gmsdf_signer_test(chunk_t data)
+{
+	int ret = 0;
+	chunk_t key = chunk_empty;
+	chunk_t sig = chunk_empty;
+	integrity_algorithm_t  alg = AUTH_HMAC_SM3;
+	signer_t *signer;
+
+	signer = lib->crypto->create_signer(lib->crypto, alg);
+	if(!signer)
+	{
+		fprintf(stderr, " mac signer create err \n");
+		return FALSE;
+	}
+
+	key = chunk_alloc(signer->get_key_size(signer));
+	memset(key.ptr, 0, key.len);
+	sig = chunk_alloc(signer->get_block_size(signer));
+
+	if(!signer->set_key(signer, key))
+	{
+		fprintf(stderr, " signer set key  failed!\n");
+	}
+
+	if(!signer->allocate_signature(signer, data, &sig))
+	{
+		fprintf(stderr, "creating signature failed!\n");
+	}
+
+	if (!signer->verify_signature(signer, data, sig))
+	{
+		fprintf(stderr, "verifying signature failed!\n");
+	}
+
+	print_hex("in  data", data.ptr, data.len);
+
+	signer->destroy(signer);
+	chunk_free(&key);
+	chunk_free(&sig);
+	return ret;
+}
+
+int gmsdf_dh_test(chunk_t data)
+{
+	int ret = 0;
+	diffie_hellman_t *dh_i, *dh_r;
+	diffie_hellman_group_t group = CURVE_SM2;
+
+	chunk_t pub_i = chunk_empty;
+	chunk_t pub_r = chunk_empty;
+	chunk_t rsecret_i = chunk_empty;
+	chunk_t rsecret_r = chunk_empty;
+
+	dh_i = lib->crypto->create_dh(lib->crypto, group);
+	if(!dh_i)
+	{
+		fprintf(stderr, " create dh 1 err \n");
+		ret = FALSE;
+	}
+
+	dh_r = lib->crypto->create_dh(lib->crypto, group);
+	if(!dh_r)
+	{
+		fprintf(stderr, " create dh 2 err \n");
+		ret = FALSE;
+	}
+
+	ret = dh_i->get_my_public_value(dh_i, &pub_i);
+	ret = dh_r->get_my_public_value(dh_r, &pub_r);
+
+	ret = dh_i->set_other_public_value(dh_i, pub_r);
+	ret = dh_r->set_other_public_value(dh_r, pub_i);
+
+	ret = dh_i->get_shared_secret(dh_i, &rsecret_i);
+	ret = dh_r->get_shared_secret(dh_r, &rsecret_r);
+
+	print_hex("out data 1", rsecret_i.ptr, rsecret_i.len);
+	print_hex("out data 2", rsecret_r.ptr, rsecret_r.len);
+
+	dh_i->destroy(dh_i);
+	dh_r->destroy(dh_r);
+	chunk_free(&rsecret_i);
+	chunk_free(&rsecret_r);
+	chunk_free(&pub_i);
+	chunk_free(&pub_r);
+	return ret;
+}
+
+int gmsdf_prf_test(chunk_t data)
+{
+	int ret = 0;
+	chunk_t key = chunk_empty;
+	chunk_t response = chunk_empty;
+	prf_t *prf = NULL;
+	pseudo_random_function_t algo = PRF_HMAC_SM3;
+
+	key = chunk_alloc(32);
+	memset(key.ptr, 0, key.len);
+
+	prf = lib->crypto->create_prf(lib->crypto, algo);
+	if (!prf)
+	{
+		printf("not supported! \r");
+		ret = FALSE;
+	}
+
+	if (prf->get_block_size(prf) < prf->get_key_size(prf))
+	{
+		printf("expansion of %N %N output not supported!\r");
+		ret = FALSE;
+	}
+
+	if (!prf->set_key(prf, key) || !prf->allocate_bytes(prf, data, &response))
+	{
+		printf("err \r");
+		ret = FALSE;
+	}
+
+	print_hex("in  data", data.ptr, data.len);
+	print_hex("out data", response.ptr, response.len);
+
+	prf->destroy(prf);
+	chunk_free(&key);
+
+	return ret;
+}
+
+int gmsdf_rng_test(chunk_t data)
+{
+	int ret = 0;
+	rng_t *rng;
+	chunk_t response = chunk_empty;
+
+	rng = lib->crypto->create_rng(lib->crypto, RNG_WEAK);
+	if (!rng || !rng->allocate_bytes(rng, 64, &response))
+	{
+		fprintf(stderr, "creating OCSP request nonce failed, no RNG found");
+	}
+
+	print_hex("out data", response.ptr, response.len);
+
+	rng->destroy(rng);
+	chunk_free(&response);
+
+	return ret;
+}
+
+int gmsdf_sm2_test(chunk_t data)
+{
+	int ret = 0;
+	return ret;
+}
+
+/**
+ * Print a credential in a human readable form
+ */
+static int crypto()
+{
+	char *arg, *file = NULL;
+	chunk_t chunk = chunk_empty;
+	int type = GMSDF_HASH;
+	int ret = 0;
+
+	while (TRUE)
+	{
+		switch (command_getopt(&arg))
+		{
+			case 'h':
+				return command_usage(NULL);
+			case 't':
+				if (streq(arg, "crypter"))
+				{
+					type = GMSDF_CRYPTER;
+				}
+				else if (streq(arg, "hash"))
+				{
+					type = GMSDF_HASH;
+				}
+				else if (streq(arg, "prf"))
+				{
+					type = GMSDF_PRF;
+				}
+				else if (streq(arg, "signer"))
+				{
+					type = GMSDF_SIGNER;
+				}
+				else if (streq(arg, "dh"))
+				{
+					type = GMSDF_DH;
+				}
+				else if (streq(arg, "rng"))
+				{
+					type = GMSDF_RNG;
+				}
+				else if (streq(arg, "sm2"))
+				{
+					type = GMSDF_SM2;
+				}
+				else
+				{
+					return command_usage( "invalid input type");
+				}
+				continue;
+			case 'i':
+				file = arg;
+				continue;
+			case EOF:
+				break;
+			default:
+				return command_usage("invalid --print option");
+		}
+		break;
+	}
+
+	if (file)
+	{
+		chunk = read_from_file(file);
+	}
+	else
+	{
+		chunk = chunk_alloc(128);
+		memset(chunk.ptr, 0, chunk.len);
+	}
+
+	switch (type)
+	{
+		case GMSDF_HASH:
+			ret = gmsdf_hash_test(chunk);
+			break;
+		case GMSDF_CRYPTER:
+			ret = gmsdf_crypter_test(chunk);
+			break;
+		case GMSDF_PRF:
+			ret = gmsdf_prf_test(chunk);
+			break;
+		case GMSDF_SIGNER:
+			ret = gmsdf_signer_test(chunk);
+			break;
+		case GMSDF_DH:
+			ret = gmsdf_dh_test(chunk);
+			break;
+		case GMSDF_RNG:
+			ret = gmsdf_rng_test(chunk);
+			break;
+		case GMSDF_SM2:
+			ret = gmsdf_sm2_test(chunk);
+			break;
+		default: command_usage("invalid --type option");
+	}
+
+	chunk_free(&chunk);
+	return ret;
+}
+
+/**
+ * Register the command.
+ */
+static void __attribute__ ((constructor))reg()
+{
+	command_register((command_t)
+			{ crypto, 'm', "crypto",
+			"crypto gm interface test",
+			{"[--in file] "
+			"[--type hash|crypter|prf|signer|dh|rng|sm2]"},
+			{
+			{"help",	'h', 0, "show usage information"},
+			{"in",		'i', 1, "input file, default: stdin"},
+			{"type",	't', 1, "type of credential, default: hash"},
+			}
+			});
+}
diff --git a/src/pki/commands/gen.c b/src/pki/commands/gen.c
index 203c76542..69eaaa91a 100644
--- a/src/pki/commands/gen.c
+++ b/src/pki/commands/gen.c
@@ -52,6 +52,10 @@ static int gen()
 				{
 					type = KEY_BLISS;
 				}
+				else if (streq(arg, "sm2"))
+				{
+					type = KEY_SM2;
+				}
 				else
 				{
 					return command_usage("invalid key type");
@@ -99,6 +103,9 @@ static int gen()
 	{
 		switch (type)
 		{
+			case KEY_SM2:
+				size = 256;
+				break;
 			case KEY_RSA:
 				size = 2048;
 				break;
@@ -166,7 +173,7 @@ static void __attribute__ ((constructor))reg()
 {
 	command_register((command_t) {
 		gen, 'g', "gen", "generate a new private key",
-		{"[--type rsa|ecdsa|ed25519|bliss] [--size bits] [--safe-primes]",
+		{"[--type rsa|ecdsa|ed25519|bliss|sm2] [--size bits] [--safe-primes]",
 		 "[--shares n] [--threshold l] [--outform der|pem]"},
 		{
 			{"help",		'h', 0, "show usage information"},
diff --git a/src/pki/commands/pub.c b/src/pki/commands/pub.c
index 1f9f3e03c..a3c4f3925 100644
--- a/src/pki/commands/pub.c
+++ b/src/pki/commands/pub.c
@@ -54,6 +54,11 @@ static int pub()
 					type = CRED_PRIVATE_KEY;
 					subtype = KEY_ECDSA;
 				}
+				else if (streq(arg, "sm2"))
+				{
+					type = CRED_PRIVATE_KEY;
+					subtype = KEY_SM2;
+				}
 				else if (streq(arg, "bliss"))
 				{
 					type = CRED_PRIVATE_KEY;
@@ -194,7 +199,7 @@ static void __attribute__ ((constructor))reg()
 	command_register((command_t) {
 		pub, 'p', "pub",
 		"extract the public key from a private key/certificate",
-		{"[--in file|--keyid hex] [--type rsa|ecdsa|bliss|priv|pub|pkcs10|x509]",
+		{"[--in file|--keyid hex] [--type rsa|ecdsa|sm2|bliss|priv|pub|pkcs10|x509]",
 		 "[--outform der|pem|dnskey|sshkey]"},
 		{
 			{"help",	'h', 0, "show usage information"},
diff --git a/src/pki/commands/req.c b/src/pki/commands/req.c
index cfddbc455..2f9c34951 100644
--- a/src/pki/commands/req.c
+++ b/src/pki/commands/req.c
@@ -59,6 +59,10 @@ static int req()
 				{
 					type = KEY_ECDSA;
 				}
+				else if (streq(arg, "sm2"))
+				{
+					type = KEY_SM2;
+				}
 				else if (streq(arg, "bliss"))
 				{
 					type = KEY_BLISS;
@@ -221,9 +225,9 @@ static void __attribute__ ((constructor))reg()
 	command_register((command_t) {
 		req, 'r', "req",
 		"create a PKCS#10 certificate request",
-		{"[--in file|--keyid hex] [--type rsa|ecdsa|bliss|priv] --dn distinguished-name",
+		{"[--in file|--keyid hex] [--type rsa|ecdsa|bliss|sm2|priv] --dn distinguished-name",
 		 "[--san subjectAltName]+ [--password challengePassword]",
-		 "[--digest md5|sha1|sha224|sha256|sha384|sha512|sha3_224|sha3_256|sha3_384|sha3_512]",
+		 "[--digest md5|sha1|sm3|sha224|sha256|sha384|sha512|sha3_224|sha3_256|sha3_384|sha3_512]",
 		 "[--rsa-padding pkcs1|pss]",
 		 "[--outform der|pem]"},
 		{
diff --git a/src/pki/commands/self.c b/src/pki/commands/self.c
index 6f7adef0f..bdff92090 100644
--- a/src/pki/commands/self.c
+++ b/src/pki/commands/self.c
@@ -105,6 +105,10 @@ static int self()
 				{
 					type = KEY_BLISS;
 				}
+				else if (streq(arg, "sm2"))
+				{
+					type = KEY_SM2;
+				}
 				else if (streq(arg, "priv"))
 				{
 					type = KEY_ANY;
@@ -400,6 +404,7 @@ static int self()
 		error = "generating certificate failed";
 		goto end;
 	}
+
 	if (!cert->get_encoding(cert, form, &encoding))
 	{
 		error = "encoding certificate failed";
@@ -454,7 +459,7 @@ static void __attribute__ ((constructor))reg()
 	command_register((command_t) {
 		self, 's', "self",
 		"create a self signed certificate",
-		{"[--in file|--keyid hex] [--type rsa|ecdsa|ed25519|bliss|priv]",
+		{"[--in file|--keyid hex] [--type rsa|ecdsa|ed25519|bliss|sm2|priv]",
 		 " --dn distinguished-name [--san subjectAltName]+",
 		 "[--lifetime days] [--serial hex] [--ca] [--ocsp uri]+",
 		 "[--flag serverAuth|clientAuth|crlSign|ocspSigning|msSmartcardLogon]+",
@@ -462,7 +467,7 @@ static void __attribute__ ((constructor))reg()
 		 "[--policy-map issuer-oid:subject-oid]",
 		 "[--policy-explicit len] [--policy-inhibit len] [--policy-any len]",
 		 "[--cert-policy oid [--cps-uri uri] [--user-notice text]]+",
-		 "[--digest md5|sha1|sha224|sha256|sha384|sha512|sha3_224|sha3_256|sha3_384|sha3_512]",
+		 "[--digest md5|sm3|sha1|sha224|sha256|sha384|sha512|sha3_224|sha3_256|sha3_384|sha3_512]",
 		 "[--rsa-padding pkcs1|pss]",
 		 "[--outform der|pem]"},
 		{
diff --git a/src/pki/commands/signcrl.c b/src/pki/commands/signcrl.c
index 50f939687..a98500781 100644
--- a/src/pki/commands/signcrl.c
+++ b/src/pki/commands/signcrl.c
@@ -469,7 +469,7 @@ static void __attribute__ ((constructor))reg()
 		 "[[--reason key-compromise|ca-compromise|affiliation-changed|",
 		 "           superseded|cessation-of-operation|certificate-hold]",
 		 " [--date timestamp] --cert file|--serial hex]*",
-		 "[--digest md5|sha1|sha224|sha256|sha384|sha512|sha3_224|sha3_256|sha3_384|sha3_512]",
+		 "[--digest md5|sm3|sha1|sha224|sha256|sha384|sha512|sha3_224|sha3_256|sha3_384|sha3_512]",
 		 "[--rsa-padding pkcs1|pss]",
 		 "[--outform der|pem]"},
 		{
diff --git a/testing/tests/gmalg/init_client.sh b/testing/tests/gmalg/init_client.sh
new file mode 100755
index 000000000..53dda6e3f
--- /dev/null
+++ b/testing/tests/gmalg/init_client.sh
@@ -0,0 +1,6 @@
+
+killall charon
+
+cp swanctl/kernel-libipsec.conf /ipsec/etc/strongswan.d/charon/
+cp swanctl/client.conf  /ipsec/etc/swanctl/conf.d/
+/ipsec/libexec/ipsec/charon &
diff --git a/testing/tests/gmalg/init_server.sh b/testing/tests/gmalg/init_server.sh
new file mode 100755
index 000000000..8e6ec1847
--- /dev/null
+++ b/testing/tests/gmalg/init_server.sh
@@ -0,0 +1,6 @@
+
+killall charon
+
+cp swanctl/kernel-libipsec.conf /ipsec/etc/strongswan.d/charon/
+cp swanctl/server.conf  /ipsec/etc/swanctl/conf.d/
+/ipsec/libexec/ipsec/charon  &
diff --git a/testing/tests/gmalg/ipsec_cert/local.sh b/testing/tests/gmalg/ipsec_cert/local.sh
new file mode 100755
index 000000000..22946fb48
--- /dev/null
+++ b/testing/tests/gmalg/ipsec_cert/local.sh
@@ -0,0 +1,8 @@
+export LD_LIBRARY_PATH=/ipsec/lib
+export PATH=/ipsec/bin:/ipsec/sbin:$PATH
+
+cp ca.cert.pem         /ipsec/etc/swanctl/x509ca
+cp server.cert.pem     /ipsec/etc/swanctl/x509
+cp server.key.pem      /ipsec/etc/swanctl/private
+cp client.cert.pem     /ipsec/etc/swanctl/x509
+cp client.key.pem      /ipsec/etc/swanctl/private
diff --git a/testing/tests/gmalg/ipsec_cert/sm2.sh b/testing/tests/gmalg/ipsec_cert/sm2.sh
new file mode 100755
index 000000000..bca368a91
--- /dev/null
+++ b/testing/tests/gmalg/ipsec_cert/sm2.sh
@@ -0,0 +1,21 @@
+export LD_LIBRARY_PATH=/ipsec/lib
+export PATH=/ipsec/bin:/ipsec/sbin:$PATH
+
+pki --gen --type sm2 --outform pem > ca.key.pem
+pki --self --in ca.key.pem --type sm2 --digest sm3 --dn "C=cn, O=ilove, CN=VPN CA" \
+		--ca --lifetime 3650 --outform pem > ca.cert.pem
+
+pki --gen --type sm2 --outform pem > server.key.pem
+pki --pub --type sm2 --in server.key.pem --outform pem > server.pub.key.pem
+pki --req --in server.key.pem --type sm2 --dn "C=cn, O=ilove, CN=VPN Server" \
+		--digest sm3 --outform pem > server.req.pem
+
+pki --issue --in server.req.pem --type pkcs10 --digest sm3 --lifetime 1200 \
+		--cacert ca.cert.pem --cakey ca.key.pem --flag serverAuth \
+		--flag ikeIntermediate --san="192.168.181.130" \
+		--outform pem > server.cert.pem
+
+pki --gen --type sm2 --outform pem > client.key.pem
+pki --pub --in client.key.pem --type sm2 | pki --issue --digest sm3 --cacert ca.cert.pem \
+		--cakey ca.key.pem --dn "C=cn, O=ilove, CN=VPN Client" \
+		--outform pem > client.cert.pem
diff --git a/testing/tests/gmalg/libipsec/kernel-libipsec.conf b/testing/tests/gmalg/libipsec/kernel-libipsec.conf
new file mode 100644
index 000000000..6487e6ff5
--- /dev/null
+++ b/testing/tests/gmalg/libipsec/kernel-libipsec.conf
@@ -0,0 +1,9 @@
+kernel-libipsec {
+
+    # Allow that the remote traffic selector equals the IKE peer.
+     allow_peer_ts = yes
+
+    # Whether to load the plugin. Can also be an integer to increase the
+    # priority of this plugin.
+      load = yes
+}
diff --git a/testing/tests/gmalg/libipsec/kernel-netlink.conf b/testing/tests/gmalg/libipsec/kernel-netlink.conf
new file mode 100644
index 000000000..aa3df66bc
--- /dev/null
+++ b/testing/tests/gmalg/libipsec/kernel-netlink.conf
@@ -0,0 +1,88 @@
+kernel-netlink {
+
+    # Buffer size for received Netlink messages.
+    # buflen = <min(PAGE_SIZE, 8192)>
+
+    # Force maximum Netlink receive buffer on Netlink socket.
+    # force_receive_buffer_size = no
+
+    # Firewall mark to set on the routing rule that directs traffic to our
+    # routing table.
+    # fwmark =
+      fwmark = !0x42
+
+
+    # Whether to ignore errors potentially resulting from a retransmission.
+    # ignore_retransmit_errors = no
+
+    # Whether to load the plugin. Can also be an integer to increase the
+    # priority of this plugin.
+    load = yes
+
+    # MSS to set on installed routes, 0 to disable.
+    # mss = 0
+
+    # MTU to set on installed routes, 0 to disable.
+    # mtu = 0
+
+    # Whether to perform concurrent Netlink ROUTE queries on a single socket.
+    # parallel_route = no
+
+    # Whether to perform concurrent Netlink XFRM queries on a single socket.
+    # parallel_xfrm = no
+
+    # Whether to always use XFRM_MSG_UPDPOLICY to install policies.
+    # policy_update = no
+
+    # Whether to use port or socket based IKE XFRM bypass policies.
+    # port_bypass = no
+
+    # Whether to process changes in routing rules to trigger roam events.
+    # process_rules = no
+
+    # Maximum Netlink socket receive buffer in bytes.
+    # receive_buffer_size = 0
+
+    # Number of Netlink message retransmissions to send on timeout.
+    # retries = 0
+
+    # Whether to trigger roam events when interfaces, addresses or routes
+    # change.
+    # roam_events = yes
+
+    # Whether to set protocol and ports in the selector installed on transport
+    # mode IPsec SAs in the kernel.
+    # set_proto_port_transport_sa = no
+
+    # Netlink message retransmission timeout, 0 to disable retransmissions.
+    # timeout = 0
+
+    # Lifetime of XFRM acquire state and allocated SPIs in kernel.
+    # xfrm_acq_expires = 165
+
+    # XFRM policy hashing threshold configuration for IPv4 and IPv6.
+    spdh_thresh {
+
+        ipv4 {
+
+            # Local subnet XFRM policy hashing threshold for IPv4.
+            # lbits = 32
+
+            # Remote subnet XFRM policy hashing threshold for IPv4.
+            # rbits = 32
+
+        }
+
+        ipv6 {
+
+            # Local subnet XFRM policy hashing threshold for IPv6.
+            # lbits = 128
+
+            # Remote subnet XFRM policy hashing threshold for IPv6.
+            # rbits = 128
+
+        }
+
+    }
+
+}
diff --git a/testing/tests/gmalg/libipsec/run_libipsec.sh b/testing/tests/gmalg/libipsec/run_libipsec.sh
new file mode 100755
index 000000000..a3e6140a9
--- /dev/null
+++ b/testing/tests/gmalg/libipsec/run_libipsec.sh
@@ -0,0 +1 @@
+cp * /ipsec/etc/strongswan.d/charon/
diff --git a/testing/tests/gmalg/libipsec/socket-default.conf b/testing/tests/gmalg/libipsec/socket-default.conf
new file mode 100644
index 000000000..38679e10c
--- /dev/null
+++ b/testing/tests/gmalg/libipsec/socket-default.conf
@@ -0,0 +1,23 @@
+socket-default {
+
+    # Firewall mark to set on outbound packets.
+    # fwmark =
+      fwmark = 0x42
+
+    # Whether to load the plugin. Can also be an integer to increase the
+    # priority of this plugin.
+    load = yes
+
+    # Set source address on outbound packets, if possible.
+    # set_source = yes
+
+    # Force sending interface on outbound packets, if possible.
+    # set_sourceif = no
+
+    # Listen on IPv4, if possible.
+    # use_ipv4 = yes
+
+    # Listen on IPv6, if possible.
+    # use_ipv6 = yes
+
+}
diff --git a/testing/tests/gmalg/run.sh b/testing/tests/gmalg/run.sh
new file mode 100755
index 000000000..35106a4ed
--- /dev/null
+++ b/testing/tests/gmalg/run.sh
@@ -0,0 +1,5 @@
+export LD_LIBRARY_PATH=/ipsec/lib
+export PATH=/ipsec/bin:/ipsec/sbin:$PATH
+
+swanctl --load-all --clear
+swanctl --initiate --chil host-host
diff --git a/testing/tests/gmalg/swanctl/client.conf b/testing/tests/gmalg/swanctl/client.conf
new file mode 100644
index 000000000..97e553624
--- /dev/null
+++ b/testing/tests/gmalg/swanctl/client.conf
@@ -0,0 +1,47 @@
+connections {
+	host-host {
+		version = 1
+		mobike = no
+
+		local_addrs = 192.168.181.129
+		remote_addrs = 192.168.181.130
+
+		local {
+			certs = client.cert.pem
+			id = "C=cn, O=ilove, CN=VPN Client"
+			auth = pubkey
+		}
+
+		remote {
+			id = "C=cn, O=ilove, CN=VPN Server"
+			auth = pubkey
+		}
+
+	#	local-xauth {
+	#		auth = xauth
+	#		xauth_id = client
+	#	}
+
+		#proposals = aes128-sha256-ecp256
+		proposals = sm4cbc-sm3-sm2dh
+
+		children {
+			host-host {
+				updown = /ipsec/libexec/ipsec/_updown iptables
+				rekey_time = 5400
+				rekey_bytes = 500000000
+				rekey_packets = 1000000
+				#esp_proposals = aes128-sha256-ecp256
+				esp_proposals = sm4cbc-sm3-sm2dh
+			}
+		}
+
+	}
+}
+
+secrets {
+	xauth-client {
+		id = client
+		secret = "123456"
+	}
+}
diff --git a/testing/tests/gmalg/swanctl/kernel-libipsec.conf b/testing/tests/gmalg/swanctl/kernel-libipsec.conf
new file mode 100644
index 000000000..7168827b3
--- /dev/null
+++ b/testing/tests/gmalg/swanctl/kernel-libipsec.conf
@@ -0,0 +1,9 @@
+kernel-libipsec {
+
+    # Allow that the remote traffic selector equals the IKE peer.
+    # allow_peer_ts = yes
+
+    # Whether to load the plugin. Can also be an integer to increase the
+    # priority of this plugin.
+    # load = yes
+}
diff --git a/testing/tests/gmalg/swanctl/server.conf b/testing/tests/gmalg/swanctl/server.conf
new file mode 100644
index 000000000..ce2e0aa12
--- /dev/null
+++ b/testing/tests/gmalg/swanctl/server.conf
@@ -0,0 +1,45 @@
+connections {
+	host-host {
+		version = 1
+		mobike = no
+
+		local_addrs = 192.168.181.130
+		remote_addrs = 192.168.181.129
+
+		local {
+			certs = server.cert.pem
+			auth = pubkey
+			id = "C=cn, O=ilove, CN=VPN Server"
+		}
+
+		remote {
+			id = "C=cn, O=ilove, CN=VPN Client"
+			auth = pubkey
+		}
+
+	#	remote-xauth {
+	#		auth = xauth
+	#	}
+
+		#proposals = aes128-sha256-ecp256
+		proposals = sm4cbc-sm3-sm2dh
+		children {
+			host-host {
+				updown = /ipsec/libexec/ipsec/_updown iptables
+				rekey_time = 5400
+				rekey_bytes = 500000000
+				rekey_packets = 1000000
+				#esp_proposals = aes128-sha256-ecp256
+				esp_proposals = sm4cbc-sm3-sm2dh
+			}
+		}
+
+	}
+}
+
+secrets {
+	xauth-client {
+		id = client
+		secret = "123456"
+	}
+}
diff --git a/testing/tests/swanctl/kernel-libipsec.conf b/testing/tests/swanctl/kernel-libipsec.conf
new file mode 100644
index 000000000..6487e6ff5
--- /dev/null
+++ b/testing/tests/swanctl/kernel-libipsec.conf
@@ -0,0 +1,9 @@
+kernel-libipsec {
+
+    # Allow that the remote traffic selector equals the IKE peer.
+     allow_peer_ts = yes
+
+    # Whether to load the plugin. Can also be an integer to increase the
+    # priority of this plugin.
+      load = yes
+}
